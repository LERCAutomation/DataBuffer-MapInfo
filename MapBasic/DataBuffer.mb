'* DataBuffer is a MapBasic tool to buffer and, optionally, consolidate
'* records from one or more MapInfo GIS layers and merge the results
'* into a single output MapInfo GIS layer.
'*
'* Copyright © 2016 - 2018 TVERC, SBIC
'* 
'* This file is part of the MapInfo tool 'DataBuffer'.
'* 
'* DataBuffer is free software: you can redistribute it and/or modify
'* it under the terms of the GNU General Public License as published by
'* the Free Software Foundation, either version 3 of the License, or
'* (at your option) any later version.
'* 
'* DataBuffer is distributed in the hope that it will be useful,
'* but WITHOUT ANY WARRANTY; without even the implied warranty of
'* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'* GNU General Public License for more details.
'* 
'* You should have received a copy of the GNU General Public License
'* along with DataBuffer.  If not, see <http://www.gnu.org/licenses/>.
'*
'***************************************************************
'* DataBuffer v1.0.8
'*
'* Buffers and (optionally) consolidates records from one or more
'* MapInfo GIS layers and merges the results into a new output
'* MapInfo GIS layer.
'*
'*
'* Created:			Andy Foy - February 2016
'* Last revised:	Andy Foy - October 2018
'*
'* *****************  Version 1.0.9  ***************
'* Author: Andy Foy		Date: 22/10/2018
'* A. Include new tool buttons for MI Pro 64bit.
'*
'* *****************  Version 1.0.7  ***************
'* Author: Andy Foy		Date: 02/09/2016
'* A. Move output column definitions and spatial
'*	  reference system in XML to OutTable node.
'* B. Set symbology for points, lines and regions in
'*	  output table.
'* C. Include column type options for Min, Max and
'*    count.
'* D. Enable buffer size to be zero.
'*
'* *****************  Version 1.0.6  ***************
'* Author: Andy Foy		Date: 14/07/2016
'* A. Enable separate instances for tool to run under
'*    different names in Tool menu.
'*
'* *****************  Version 1.0.5  ****************
'* Author: Andy Foy		Date: 30/05/2016
'* A. Change version number to 3 parts.
'*
'* *****************  Version 1.04  *****************
'* Author: Andy Foy		Date: 01/04/2016
'* A. Include where clause for input tables.
'*
'* *****************  Version 1.03  *****************
'* Author: Andy Foy		Date: 17/03/2016
'* A. Performance improvements.
'* B. Updated user interface.
'*
'* *****************  Version 1.02  *****************
'* Author: Andy Foy		Date: 09/03/2016
'* A. Ask user if they want to keep the dialog open.
'* B. Open log file using Notepad.exe.
'* 
'* *****************  Version 1.01  *****************
'* Author: Andy Foy		Date: 24/02/2016
'* A. Initial version of tool.
'* 
'***************************************************************
Include "DataBuffer.def"

Sub Main
'***************************************************************
'* Main sub-routine
'***************************************************************

	OnError Goto HandleError

	'-------------------------------------------------
	' Set the version number
	'-------------------------------------------------
	sVersion = "1.0.8"

	'-------------------------------------------------
	' Get the title for the Tool menu
	'-------------------------------------------------
	Call GetToolTitle

	Call CreateToolMenu(sToolTitle)
	
	Exit Sub

HandleError:
	Note "Main: " + Error$()
	Resume Next

End Sub

Sub GetToolTitle
'***************************************************************
'* Retrieve the tool title to use from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode

	OnError Goto GetTitleError

	' Set the default Tool menu title
	sToolTitle = "Data Buffer"

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataBuffer.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Load the default values from the child nodes
					' under the DataBuffer node
					'-------------------------------------------------
					' Title for adding the program to the Tool menu
					Dim sTitle As String
					sTitle = GetSingleNodeValue(hXMLNode, "ToolTitle")
					If sTitle <> "" Then
						sToolTitle = sTitle
					End If

				End If

			End If

		Else

			Goto GetTitleError

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetTitleError:
	Note "Unable to get tool title from XML config file.  Using default title 'Data Buffer'."
	Exit Sub

End Sub

Sub GetDefaultValues
'***************************************************************
'* Retrieve all the default values from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLFilesNodeList As MIXMLNodeList
	Dim hXMLFilesNodeParent As MIXmlNode
	Dim hXMLFilesNode As MIXmlNode
	Dim hXMLColumnsNode As MIXmlNode

	OnError Goto GetVariablesError

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataBuffer.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
				If hXMLNode Then
	
					'-------------------------------------------------
					' Load the default values from the child nodes
					' under the DataBuffer node
					'-------------------------------------------------
					' File path for storing the log file
					Dim sLogFilePath As string
					sLogFilePath = GetSingleNodeValue(hXMLNode, "LogFilePath")
					sLogFileName = sLogFilePath & "\DataBuffer_" & sUserID & ".log"

					' Default file path to store extracts in sub-folders
					sDefaultPath = GetSingleNodeValue(hXMLNode, "DefaultPath")

					'-------------------------------------------------
					' Get a handle on the input tables node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "InTables")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLFilesNodeParent)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the values in an array
					'-------------------------------------------------
					Redim aInTables(99)
					Dim i As Integer
					i = 0
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the table node
						aInTables(i).Node = GetNodeName(hXMLFilesNode)

						' Name of the MapInfo table to be input
						aInTables(i).TableName = GetSingleNodeValue(hXMLFilesNode, "TableName")

						' The columns to read from the input table
						aInTables(i).Columns = GetSingleNodeValue(hXMLFilesNode, "Columns")

						' The where clause to apply to the input table
						aInTables(i).WhereClause = GetSingleNodeValue(hXMLFilesNode, "WhereClause")

						' The column sort order to read the input table
						aInTables(i).SortOrder = GetSingleNodeValue(hXMLFilesNode, "SortOrder")

						' The size of the buffer to apply to the records
						aInTables(i).BufferSize = GetSingleNodeValue(hXMLFilesNode, "BufferSize")

						' The proximity of records to be dissolved together
						aInTables(i).DissolveSize = GetSingleNodeValue(hXMLFilesNode, "DissolveSize")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim aInTables(i)

					'-------------------------------------------------
					' Get a handle on the output table node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "OutTable")

					' Definitions of the columns in the new table
					sOutColumnDefs = GetSingleNodeValue(hXMLFilesNodeParent, "ColumnDefs")

					' Coordinate system to be used for mapping
					sCoordSys = GetSingleNodeValue(hXMLFilesNodeParent, "CoordinateSystem")

					'-------------------------------------------------
					' Get a handle on the columns node for the table
					'-------------------------------------------------
					hXMLColumnsNode = MIXmlSelectSingleNode(hXMLFilesNodeParent, "Columns")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLColumnsNode)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the values in an array
					'-------------------------------------------------
					Redim aOutColumns(99)
					i = 0
					sOutColumns = ""
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the column node
						aOutColumns(i).Node = GetNodeName(hXMLFilesNode)
						If i > 1 Then
							sOutColumns = sOutColumns + ", "
						End If
						sOutColumns = sOutColumns + GetNodeName(hXMLFilesNode)

						' Name of the column to be output to the new buffered layer
						aOutColumns(i).ColumnName = GetSingleNodeValue(hXMLFilesNode, "ColumnName")

						' Type of column to be output to the new buffered layer
						aOutColumns(i).ColumnType = GetSingleNodeValue(hXMLFilesNode, "ColumnType")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim aOutColumns(i)

				End If

			End If

		Else

			Note "Error opening XML config file 'DataBuffer.xml'."

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLColumnsNode Then Call MIXmlNodeDestroy(hXMLColumnsNode) End If
	If hXMLFilesNode Then Call MIXmlNodeDestroy(hXMLFilesNode) End If
	If hXMLFilesNodeList Then Call MIXmlNodeListDestroy(hXMLFilesNodeList) End If
	If hXMLFilesNodeParent Then Call MIXmlNodeDestroy(hXMLFilesNodeParent) End If
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetVariablesError:
	Note "Error: " + str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Sub DataBuffer
'***************************************************************
'* Create the user dialog window
'***************************************************************

	'-------------------------------------------------
	' Trap errors
	'-------------------------------------------------
    OnError Goto ErrorTrap

	'-------------------------------------------------
	' Get the current user ID
	'-------------------------------------------------
	sUserID = GetUserID()
	sUserID = StringReplace(sUserID, " ", "_")
	sUserID = StringReplace(sUserID, ".", "_")

	'-------------------------------------------------
	' Retrieve the default values from the config file
	'-------------------------------------------------
	Call GetDefaultValues

	'-------------------------------------------------
	' Build a new dialog window
	'-------------------------------------------------
	Dialog
		Title "Data Buffer " + sVersion
		Width 160
		Height 190
		Position 50, 70
		Calling DialogSetup

	'-------------------------------------------------
	' Add a input table listbox
	'-------------------------------------------------
	Control StaticText Title "Input Tables:"
		Position 10, 10
	Control MultiListBox
		ID 1
		Title ""
		Position 10, 20
		Height 120
		Width 140

	'-------------------------------------------------
	' Add a checkbox for clearing the log file
	'-------------------------------------------------
	Control CheckBox
		ID 6
		Title "Clear log file?"
		Position 10,150
		Value TRUE
		'Into bClearLog

	'-------------------------------------------------
	' Add Ok and cancel buttons
	'-------------------------------------------------
	Control CancelButton
		Position 65,170
		Width 40
	Control Button
		Title "Ok"
		Position 110,170
		Width 40
		Calling CheckSelection

Done:
	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Resume Done

End Sub

Sub DialogSetup
'***************************************************************
' Setup the dialog window listboxes
'***************************************************************

	'-------------------------------------------------
	' Clear the Message window and close it
	'-------------------------------------------------
	Print(chr$(12))
	Close Window Message

	'-------------------------------------------------
	' Store the names of any tables not open
	'-------------------------------------------------
	Dim sClosedTables As String, iClosedCount as Integer
	sClosedTables = ""
	iClosedCount = 0
	
	'-------------------------------------------------
	' Loop through all the input tables listed in the
	' config file and add them to the input Table list
	' if they are open in MapInfo
	'-------------------------------------------------
	Dim i, j As Integer
	Dim aOpenTables(99) As String
	Redim aOpenTables(99)
	Redim aInTablesOpen(99)
	j = 0
	For i = 1 to UBound(aInTables)

		'-------------------------------------------------
		' Concatenate all the Map tables into an array
		'-------------------------------------------------
		If TableIsOpen(aInTables(i).TableName) Then
			j = j + 1
			aOpenTables(j) = aInTables(i).TableName
			aInTablesOpen(j).Node = aInTables(i).Node
			aInTablesOpen(j).TableName = aInTables(i).TableName
			aInTablesOpen(j).Columns = aInTables(i).Columns
			aInTablesOpen(j).WhereClause = aInTables(i).WhereClause
			aInTablesOpen(j).SortOrder = aInTables(i).SortOrder
			aInTablesOpen(j).BufferSize = aInTables(i).BufferSize
			aInTablesOpen(j).DissolveSize = aInTables(i).DissolveSize
		Else
			'-------------------------------------------------
			' Store the name of the closed table
			'-------------------------------------------------
			sClosedTables = sClosedTables + Chr$(13) + aInTables(i).TableName
			iClosedCount = iClosedCount + 1
		End If

	Next

	Redim aInTablesOpen(j)
	Redim aOpenTables(j)

	'-------------------------------------------------
	' Update the input table list to show the list
	' of open tables
	'-------------------------------------------------
	Alter Control 1 Title FROM Variable aOpenTables

	'-------------------------------------------------
	' Warn the user of the closed tables
	'-------------------------------------------------
	If iClosedCount > 0 Then
		If iClosedCount = 1 Then
			Note "Warning: the following table is not open ..." + Chr$(13) + sClosedTables
		Else
			Note "Warning: " + iClosedCount + " tables are not open, including ..." + Chr$(13)+ sClosedTables
		End If
	End If

End Sub

Sub CheckSelection
'***************************************************************
'* Check the user's selections and process according
'***************************************************************

	'-------------------------------------------------
	' Store the dialog variables
	'-------------------------------------------------
	bClearLog = ReadControlValue(6)

	'-------------------------------------------------
	' Check if the user has selected at least one input
	' table
	'-------------------------------------------------
	iInTable = ReadControlValue(1)
	if iInTable = 0 then
		Note "No input tables have been selected!"
		Exit Sub
	End If

	'-------------------------------------------------
	' Reset the global variables
	'-------------------------------------------------
	iInTableTot = 0
	iInTableCnt = 0

	'-------------------------------------------------
	' Count the number of input tables to process
	'-------------------------------------------------
	Do While iInTable > 0
	
		'-------------------------------------------------
		' Increment the counters
		'-------------------------------------------------
		iInTableTot = iInTableTot + 1

		aInTablesSelected(iInTableTot).Node = aInTablesOpen(iInTable).Node
		aInTablesSelected(iInTableTot).TableName = aInTablesOpen(iInTable).TableName
		aInTablesSelected(iInTableTot).Columns = aInTablesOpen(iInTable).Columns
		aInTablesSelected(iInTableTot).WhereClause = aInTablesOpen(iInTable).WhereClause
		aInTablesSelected(iInTableTot).SortOrder = aInTablesOpen(iInTable).SortOrder
		aInTablesSelected(iInTableTot).BufferSize = aInTablesOpen(iInTable).BufferSize
		aInTablesSelected(iInTableTot).DissolveSize = aInTablesOpen(iInTable).DissolveSize

		'-------------------------------------------------
		' Read the next input table selected in the list
		'-------------------------------------------------
		iInTable = ReadControlValue(1)

	Loop

	'-------------------------------------------------
	' Prompt the user for the output file destination
	'-------------------------------------------------
	Dim sOutputFile As String
	sOutputFile = FileSaveAsDlg(sDefaultPath, "", "TAB", "Select where to save the output file")

	if sOutputFile = "" then
		Call MyPrint("No output file selected - process cancelled")
		Note "No output file selected - process cancelled"
		Exit Sub
	End If

	'-------------------------------------------------
	' Get the path and name of the selected output file
	'-------------------------------------------------
	sOutputPath = PathToDirectory$(sOutputFile)
	sOutputName = PathToFileName$(sOutputFile)

	'-------------------------------------------------
	' Check the selected directory already exists
	'-------------------------------------------------
	Dim iSuccess, iSecurity As Integer
	iSecurity = 0
	iSuccess = SetCurrentDirectory(sOutputPath)
	if iSuccess = 0 Then
		Call MyPrint("Output folder does not exist - process cancelled")
		Note "Output folder does not exist - process cancelled"
		Exit Sub
	End If

	'-------------------------------------------------
	' Check the selected file name has the correct
	' extension
	'-------------------------------------------------
	if UCase$(Right$(sOutputName, 3)) <> UCase$("TAB") Then
		Call MyPrint("Output file has incorrect extension - process cancelled")
		Note "Output file has incorrect extension - process cancelled"
		Exit Sub
	End If

	'-------------------------------------------------
	' Clear the log file (if it exists)
	'-------------------------------------------------
	If bClearLog = True Then
		If FileExists(sLogFileName) Then
			Kill sLogFileName
		End If

	End If

	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("Process started!")
	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("")

	'-------------------------------------------------
	' Remove the file extension from the output file name
	'-------------------------------------------------
	sOutputName = Left$(sOutputName, Len(sOutputName) - 4)

	Call MyPrint("Output File = '" + sOutputFile + "'")

	'-------------------------------------------------
	' Call the subroutine to create the new
	' output buffer table.
	'-------------------------------------------------
	Call CreateBufferTable(sOutputPath, sOutputName)
	Dim lResponse As Logical
	If sOutputName = "" Then
		Call MyPrint("Error creating output buffer table.")
		Call MyPrint("")
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process stopped!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Process stopped!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
		Goto Response
	End If

	'-------------------------------------------------
	' Process the selected tables one by one
	'-------------------------------------------------
	iInTableCnt = 1
	ProgressBar "Processing " + iInTableTot + " input tables ..."
		Calling ProcessTables
		Range iInTableTot

	'-------------------------------------------------
	' If the process was interrupted by the user
	'-------------------------------------------------
	If Not CommandInfo(CMD_INFO_STATUS) Then
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process interrupted by user!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Processing interrupted!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
		Goto Response
	End If

	Set ProgressBars Off

	'-------------------------------------------------
	' Drop the temporary column
	'-------------------------------------------------
	Alter Table sOutputName (Drop Temp)

	'-------------------------------------------------
	' Pack the output table
	'-------------------------------------------------
	Pack Table sOutputName Graphic Data

	Set ProgressBars On

	'-------------------------------------------------
	' Count the number of buffered records
	'-------------------------------------------------
	Dim iRows As Integer
	iRows = TableInfo(sOutputName, TAB_INFO_NROWS)

	Call MyPrint("Created a total of " + FormatNumber$(iRows) + " buffered features")
	Call MyPrint("")
	
	'-------------------------------------------------
	' Turn on FastEdit to speed up the updates
	'-------------------------------------------------
	Set Table sOutputName FastEdit On

	'-------------------------------------------------
	' Set the symbology for the table before closing
	'-------------------------------------------------
	Call SetSymbology(sOutputName)

	Dim sCmd As String
	sCmd = "Commit Table " + sOutputName
	Run Command (sCmd)

	'-------------------------------------------------
	' Turn FastEdit off once updates are done
	'-------------------------------------------------
	Set Table sOutputName FastEdit Off

	'-------------------------------------------------
	' Add the output table to the top most map window
	' (if there is one), otherwise create a new map
	' window using the table
	'-------------------------------------------------
	If NumWindows() > 0 Then
		Add Map Layer sOutputName
	Else
		Map From sOutputName
	End If

	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("Process completed!")
	Call MyPrint("----------------------------------------------------------------------")

	'-------------------------------------------------
	' Ask the user if they want to close the form
	'-------------------------------------------------
	lResponse = Ask("Processing complete!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")

Response:
	If lResponse = True Then
		'-------------------------------------------------
		' Close the dialog
		'-------------------------------------------------
		Dialog Remove

	End If

	'-------------------------------------------------
	' Display the log file in the message window
	'-------------------------------------------------
	Call PrintLogFile

End Sub

Sub CreateBufferTable (sOutputPath As String, sOutputName As String)
'*************************************************
'* Routine to create a new output buffer table.
'*************************************************

	'-------------------------------------------------
	' Replace any spaces in the output table name with
	' underscores and remove hyphens
	'-------------------------------------------------
	sOutputName = StringReplace(sOutputName, " ", "_")
	sOutputName = StringReplace(sOutputName, "-", "")

	'-------------------------------------------------
	' Check if an existing output table is
	' already/still open and close it if it is
	'-------------------------------------------------
	If TableIsOpen(sOutputName) Then
		Call MyPrint("Closing old output buffer table ...")
		Close Table sOutputName
	End If

	OnError Goto CreateError

	Call MyPrint("Creating output buffer table ...")

	'-------------------------------------------------
	' Create new output table"
	'-------------------------------------------------
	Dim sCmd As String
	sCmd = "Create Table " + Chr$(34) + sOutputName + Chr$(34) + " (" + sOutColumnDefs + ", Temp Integer) file " + Chr$(34) + sOutputPath + sOutputName + ".tab" + Chr$(34)
	+ " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
	Run Command (sCmd)

	'-------------------------------------------------
	' Add an index to the temp field to speed
	' up queries
	'-------------------------------------------------
	sCmd = "Create Index On " + sOutputName + "(temp)"
	Run Command (sCmd)

	'-------------------------------------------------
	' Make output table mappable
	'-------------------------------------------------
	sCmd = "Create Map For " + sOutputName + " CoordSys " + sCoordSys
	Run Command (sCmd)

'	'-------------------------------------------------
'	' Find the layer number of the search table by
'	' looking through all the windows until it is
'	' found
'	'-------------------------------------------------
'	Dim iNumWindows As Integer
'	iNumWindows = UBound(aWindowId)
'	Dim iWindowNum As Integer
'	For iWindowNum = 1 to iNumWindows
'		Dim iNumTables As Integer
'		Dim iNumSearchTable as Integer
'		iNumTables = MapperInfo(aWindowId(iWindowNum), MAPPER_INFO_LAYERS)
'		For iNumSearchTable = 1 to iNumTables
'			If LayerInfo(aWindowId(iWindowNum),iNumSearchTable, LAYER_INFO_NAME) = sSearchTable Then
'				Goto EditLayer
'			End If
'		Next
'	Next
'
'EditLayer:
'	'-------------------------------------------------
'	' Make the layer editable
'	'-------------------------------------------------
'	If LayerInfo(aWindowId(iWindowNum),iNumSearchTable,LAYER_INFO_EDITABLE) = False Then
'		Set Map Window aWindowId(iWindowNum) Layer iNumSearchTable Editable On
'	End If

	Call MyPrint("Created output buffer table.")
	Call MyPrint("")

	Exit Sub

CreateError:
	sOutputName = ""

End Sub

Sub ProcessTables()
'***************************************************************
'* Process the input table
'***************************************************************

	Dim sNodeName, sTableName, sColumns, sWhereClause, sSortOrder As String
	Dim iBufferSize, iDissolveSize As Integer
	sNodeName = aInTablesSelected(iInTableCnt).Node
	sTableName = aInTablesSelected(iInTableCnt).TableName
	sColumns = aInTablesSelected(iInTableCnt).Columns
	sWhereClause = aInTablesSelected(iInTableCnt).WhereClause
	sSortOrder = aInTablesSelected(iInTableCnt).SortOrder
	iBufferSize = aInTablesSelected(iInTableCnt).BufferSize
	iDissolveSize = aInTablesSelected(iInTableCnt).DissolveSize

	Call MyPrint("Processing table " + sTableName + " (" + iInTableCnt + " of " + iInTableTot + ") ...")

	'-------------------------------------------------
	' Call the subroutine to select the records from
	' the selected table for the selected partner
	'-------------------------------------------------
	Call BufferRecords(sTableName, sColumns, sWhereClause, sSortOrder, iBufferSize, iDissolveSize)

	Call MyPrint("Completed process " + iInTableCnt + " of " + iInTableTot + ".")
	Call MyPrint("")

	'-------------------------------------------------
	' Increment the progress bar to show progress
	'-------------------------------------------------
	ProgressBar = iInTableCnt

	'-------------------------------------------------
	' Go to the next selection in the list
	'-------------------------------------------------
	iInTableCnt = iInTableCnt + 1
	If iInTableCnt > iInTableTot Then
		'-------------------------------------------------
		' Halt processing
		'-------------------------------------------------
		ProgressBar = -1
	End If

End Sub

Sub BufferRecords
	(sTableName As String,
	sColumns As String,
	sWhereClause As String,
	sSortOrder As String,
	iBufferSize As Integer,
	iDissolveSize As Integer)
'*************************************************
'* Routine to select the records from the
'* MapInfo table name passed in the call, buffer
'* and/or dissolve them and copy them to the
'* output table.
'*************************************************

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Setup the temporary table names
	'-------------------------------------------------
	Dim sTempInput, sTempOutput As String
	sTempInput = "TempInput"
	sTempOutput = "TempOutput"

	Dim sTempSelect As String
	sTempSelect = "TempSelect"

	Dim sTempCluster As String
	sTempCluster = "TempCluster"

	'-------------------------------------------------
	' Check if the temporary tables are already/still
	' open and close them if it is
	'-------------------------------------------------
	If TableIsOpen(sTempInput) Then
		Close Table sTempInput
	End If

	If TableIsOpen(sTempOutput) Then
		Close Table sTempOutput
	End If

	If TableIsOpen(sTempSelect) Then
		Close Table sTempSelect
	End If

	If TableIsOpen(sTempCluster) Then
		Close Table sTempCluster
	End If

	'-------------------------------------------------
	' If a temporary unique column doesn't already
	' exist
	'-------------------------------------------------
	If Not ColumnExists(sTableName, "RowInd") Then

		Call MyPrint("Adding temporary key to " + sTableName + " ...")

		'-------------------------------------------------
		' Add a temporary unique column
		'-------------------------------------------------
		Alter Table sTableName (Add RowInd Integer)

		'-------------------------------------------------
		' Add an index to the unique column to speed
		' up queries
		'-------------------------------------------------
		Dim sCmd As String
		sCmd = "Create Index On " + sTableName + "(RowInd)"
		Run Command (sCmd)

	End If

	'-------------------------------------------------
	' Update the unique column in the table
	'-------------------------------------------------
	sCmd = "Select RowInd From " + sTableName + " Order By " + sSortOrder + " Into " + sTempInput + " NoSelect"
	Run Command (sCmd)

	sCmd = "Update " + sTempInput + " Set RowInd = RowID"
	Run Command (sCmd)

	'-------------------------------------------------
	' Save the updates
	'-------------------------------------------------
	sCmd = "Commit Table " + sTableName
	Run Command (sCmd)
	
	Call MyPrint("Buffering features to " + iBufferSize + " metres ...")

	'-------------------------------------------------
	' Check if the records need to be clustered
	'-------------------------------------------------
	Dim bCluster As Logical, iClusterSize As Integer
	iClusterSize = iDissolveSize - 1
	If iClusterSize > 0 Then
		bCluster = True
	End If

	'-------------------------------------------------
	' If the records need to be clustered (dissolved)
	'-------------------------------------------------
	If bCluster Then

		Call MyPrint("Clustering features within " + iDissolveSize + " metres ...")

		'-------------------------------------------------
		' Create a new cluster table for the input records
		' if they are to be dissolved
		'-------------------------------------------------
		sCmd = "Create Table " + Chr$(34) + sTempCluster + Chr$(34) + " (ClusterID Integer) file " + Chr$(34) + sOutputPath + "\" + sTempCluster + ".tab" + Chr$(34) + " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Make the cluster table mappable
		'-------------------------------------------------
		sCmd = "Create Map For " + sTempCluster + " CoordSys " + sCoordSys
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Turn on FastEdit to speed up the updates
		'-------------------------------------------------
		Set Table sTempCluster FastEdit On
		Set Table sTempCluster Undo Off

		'-------------------------------------------------
		' Create a single clustered object
		'-------------------------------------------------
		sCmd = "Create Object As Buffer From " + sTableName + " Width " + iClusterSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sTempCluster
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Disaggregate the clustered object
		'-------------------------------------------------
		sCmd = "Objects Disaggregate Into Table " + sTempCluster
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Update the ClusterId in the table
		'-------------------------------------------------
		sCmd = "Update " + sTempCluster + " Set ClusterID = RowID - 1"
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Save the clustered objects
		'-------------------------------------------------
		sCmd = "Commit Table " + sTempCluster
		Run Command (sCmd)
		
		'-------------------------------------------------
		' Turn off FastEdit after updates
		'-------------------------------------------------
		Set Table sTempCluster FastEdit Off
		Set Table sTempCluster Undo On

		'-------------------------------------------------
		' Close the latest query table
		'-------------------------------------------------
		Dim t As SmallInt
		For t = NumTables() to 1 Step -1
			If TableInfo(t, TAB_INFO_TEMP) Then
				Close Table TableInfo(t, TAB_INFO_NAME)
				Exit For
			End If
		Next

	End If

	'-------------------------------------------------
	' If the records need to be clustered (dissolved)
	' then include the cluster ID from the overlapping
	' cluster
	'-------------------------------------------------
	If bCluster Then
		If sWhereClause <> "" Then
			sWhereClause = " And " + sWhereClause
		End If
		sCmd = "Select " + sColumns + ", " + sTableName + ".Obj, ClusterID, RowInd From " + sTableName + ", " + sTempCluster + " Where " + sTableName + ".Obj Within " + sTempCluster + ".Obj" + sWhereClause + " Order By ClusterID, RowInd Into " + sTempInput + " NoSelect"
	Else
		If sWhereClause <> "" Then
			sWhereClause = " Where " + sWhereClause
		End If
		sCmd = "Select " + sColumns + ", Obj, 0" + Chr$(34) + "ClusterID" + Chr$(34) + ", RowInd From " + sTableName + sWhereClause + " Order By RowInd Into " + sTempInput + " NoSelect"
	End If
	Run Command (sCmd)

	'-------------------------------------------------
	' Count the number of rows selected
	'-------------------------------------------------
	Dim iRows As Integer
	iRows = TableInfo(sTempInput, TAB_INFO_NROWS)

	Call MyPrint("Buffering " + FormatNumber$(iRows) + " features ...")	
	
	'-------------------------------------------------
	' Reset the output counter
	'-------------------------------------------------
	Dim iOutCount As Integer
	iOutCount = 0

	'-------------------------------------------------
	' Reset the column values
	'-------------------------------------------------
	Dim iColumn As Integer
	For iColumn = 1 to UBound(aOutColumns)
		aColumnValues(iColumn).ValKey = ""
		aColumnValues(iColumn).ValMin = ""
		aColumnValues(iColumn).ValMax = ""
		aColumnValues(iColumn).ValFirst = ""
		aColumnValues(iColumn).ValCommon = ""
	Next

	'-------------------------------------------------
	' Turn on FastEdit to speed up the updates
	'-------------------------------------------------
	Set Table sOutputName FastEdit On
	Set Table sOutputName Undo Off

	'-------------------------------------------------
	' If any rows were selected then set the object
	'-------------------------------------------------
	If iRows > 0 Then

		'-------------------------------------------------
		' Set the coordinate system to that of the table
		'-------------------------------------------------
		Set Coordsys table TempInput

		'-------------------------------------------------
		' Fetch the first of the selected rows
		'-------------------------------------------------
		Fetch First from TempInput

		Dim aColumn As Alias, sColumnVal As String
		Dim bSame As Logical
		bSame = False
		
		Dim iLastClusterId As Integer
		iLastClusterId = 0
	
		'-------------------------------------------------
		' Loop through all the selected rows buffer the
		' spatial objects
		'-------------------------------------------------
		Dim iRow as Integer
		iRow = 1
		Do while iRow <= iRows

			'-------------------------------------------------
			' If this is not the same cluster
			'-------------------------------------------------
			If iLastClusterId <> TempInput.ClusterID Then

				bSame = False

			Else

				'-------------------------------------------------
				' Loop through every column in the output table
				' to check if the key columns have changed
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Check if the key columns have changed from the
					' last record
					'-------------------------------------------------
					Do Case aOutColumns(iColumn).ColumnType
						Case "Key"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempInput.Col" + iColumn
			
							'-------------------------------------------------
							' Get the value of the column (and remove double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
					
							'-------------------------------------------------
							' Check if the value has changed
							'-------------------------------------------------
							If aColumnValues(iColumn).ValKey <> sColumnVal Then
								bSame = False
							End If
						Case "Cluster"
							'-------------------------------------------------
							' Only check values if the records are not being
							' clustered.
							'-------------------------------------------------
							If bCluster = False Then
								'-------------------------------------------------
								' Set an alias for the column
								'-------------------------------------------------
								aColumn = "TempInput.Col" + iColumn
				
								'-------------------------------------------------
								' Get the value of the column (and remove any
								' double quotes)
								'-------------------------------------------------
								sColumnVal = aColumn
								If Instr(1, sColumnVal, Chr$(34)) > 0 Then
									sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
								End If
						
								'-------------------------------------------------
								' Check if the value has changed
								'-------------------------------------------------
								If aColumnValues(iColumn).ValKey <> sColumnVal Then
									bSame = False
								End If
							End If
						Case Else
					End Case
				Next
			
			End If

			'-------------------------------------------------
			' If the key columns have not changed and this is
			' the same cluster
			'-------------------------------------------------
			If bSame = True Then

				'-------------------------------------------------
				' Loop through every column in the output table
				' to update the values
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Check if the range columns have changed
					'-------------------------------------------------
					Do Case aOutColumns(iColumn).ColumnType
						Case "Range"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempInput.Col" + iColumn
							
							'-------------------------------------------------
							' Get the value of the column (and remove any
							' double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
				
							' Check if the min or max values have changed
							If sColumnVal < aColumnValues(iColumn).ValMin Then
								aColumnValues(iColumn).ValMin = sColumnVal
							End If
							If sColumnVal > aColumnValues(iColumn).ValMax Then
								aColumnValues(iColumn).ValMax = sColumnVal
							End If
						Case "Min"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempInput.Col" + iColumn
							
							'-------------------------------------------------
							' Get the value of the column (and remove any
							' double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
				
							' Check if the min value has changed
							If sColumnVal < aColumnValues(iColumn).ValMin Then
								aColumnValues(iColumn).ValMin = sColumnVal
							End If
						Case "Max"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempInput.Col" + iColumn
							
							'-------------------------------------------------
							' Get the value of the column (and remove any
							' double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
				
							' Check if the max value has changed
							If sColumnVal > aColumnValues(iColumn).ValMax Then
								aColumnValues(iColumn).ValMax = sColumnVal
							End If
						Case Else
					End Case
					
				Next		

			'-------------------------------------------------
			' If the key columns have changed
			'-------------------------------------------------
			Else

				If iRow > 1 Then

					'-------------------------------------------------
					' Select all the 'Temp' objects
					'-------------------------------------------------
					sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
					Run Command (sCmd)

					'-------------------------------------------------
					' Count the number of objects
					'-------------------------------------------------
					Dim iRecs As Integer
					iRecs = TableInfo(sTempOutput, TAB_INFO_NROWS)

					'-------------------------------------------------
					' Loop through every column in the output table
					' to set the values
					'-------------------------------------------------
					Dim sData As String
					sData = " Data "
					For iColumn = 1 to UBound(aOutColumns)
	
						Do Case aOutColumns(iColumn).ColumnType
							Case "Key"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
							Case "Cluster"
								If bCluster = False Then
									sColumnVal = aColumnValues(iColumn).ValKey
									sColumnVal = StringReplace(sColumnVal, Chr$(34), "")

									sData = sData + " Col" + iColumn + " = " + Chr$(34) + sColumnVal + Chr$(34)
								Else
									sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
									Run Command (sCmd)
									Fetch First from TempCommon
									
									Dim sCommonVal As String
									sCommonVal = TempCommon.Col1
									sCommonVal = StringReplace(sCommonVal, Chr$(34), "")
	
									'If TableIsOpen("TempCommon") Then
									'	Close Table TempCommon
									'End If
	
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
								End If
							Case "First"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValFirst + Chr$(34)
							Case "Common"
								sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
								Run Command (sCmd)
								Fetch First from TempCommon
								
								sCommonVal = TempCommon.Col1
								sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

								'If TableIsOpen("TempCommon") Then
								'	Close Table TempCommon
								'End If

								sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
							Case "Range"
								If aColumnValues(iColumn).ValMin = aColumnValues(iColumn).ValMax Then
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
								Else
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + " - " + aColumnValues(iColumn).ValMax + Chr$(34)
								End If
							Case "Min"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
							Case "Max"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMax + Chr$(34)
							Case "Count"
								sData = sData + " Col" + iColumn + " = " + iRecs
							Case Else
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
						End Case
						
						sData = sData + ","
						
					Next
						
					sData = sData + " Temp = 0"
						
					'-------------------------------------------------
					' Create a buffered object from the 'Temp' objects
					'-------------------------------------------------
					If iBufferSize > 0 then
						sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
					Else
						sCmd = "Create Object As Union From " + sTempOutput + " Into Table " + sOutputName + sData
					End If
					Run Command (sCmd)

					'-------------------------------------------------
					' Increment the output counter
					'-------------------------------------------------
					iOutCount = iOutCount + 1

					'-------------------------------------------------
					' Delete all the original 'Temp' objects
					'-------------------------------------------------
					sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
					Run Command (sCmd)

					sCmd = "Delete From " + sTempOutput
					Run Command (sCmd)

				End If

				'-------------------------------------------------
				' Loop through every column in the output table
				' to set the values
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Set an alias for the column
					'-------------------------------------------------
					aColumn = "TempInput.Col" + iColumn

					'-------------------------------------------------
					' Get the value of the column (and remove any
					' double quotes)
					'-------------------------------------------------
					sColumnVal = aColumn
					If Instr(1, sColumnVal, Chr$(34)) > 0 Then
						sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
					End If				
	
					'-------------------------------------------------
					' Set the column values
					'-------------------------------------------------
					aColumnValues(iColumn).ValKey = sColumnVal
					aColumnValues(iColumn).ValMin = sColumnVal
					aColumnValues(iColumn).ValMax = sColumnVal
					aColumnValues(iColumn).ValFirst = sColumnVal
					aColumnValues(iColumn).ValCommon = sColumnVal
					
					'-------------------------------------------------
					' Store the cluster ID
					'-------------------------------------------------
					iLastClusterId = TempInput.ClusterID
					
				Next
				
				bSame = True
				
			End If

			'-------------------------------------------------
			' Copy the record into the output table as a
			' 'Temp' object
			'-------------------------------------------------
			sCmd = "Select " + sColumns + ", 1 " + Chr$(34) + "Temp" + Chr$(34) + ", Obj From " + sTableName + " Where RowInd = " + TempInput.RowInd + " Into TempInsert NoSelect"
			Run Command (sCmd)

			sCmd = "Insert Into " + sOutputName + " (" + sOutColumns + ", Temp, Obj) Select * From TempInsert"
			Run Command (sCmd)

			'If TableIsOpen("TempInsert") Then
			'	Close Table TempInsert
			'End If

			'-------------------------------------------------
			' Fetch the next of the selected rows
			'-------------------------------------------------
			Fetch Next From sTempInput
			iRow = iRow + 1

		Loop

		'-------------------------------------------------
		' Process the final row ...
		'-------------------------------------------------

		'-------------------------------------------------
		' Select all the 'Temp' objects
		'-------------------------------------------------
		sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
		Run Command (sCmd)

		'-------------------------------------------------
		' Count the number of objects
		'-------------------------------------------------
		iRecs = TableInfo(sTempOutput, TAB_INFO_NROWS)

		'-------------------------------------------------
		' Loop through every column in the output table
		' to set the values
		'-------------------------------------------------
		sData = " Data "
		For iColumn = 1 to UBound(aOutColumns)

			Do Case aOutColumns(iColumn).ColumnType
				Case "Key"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
				Case "Cluster"
					If bCluster = False Then
						sColumnVal = aColumnValues(iColumn).ValKey
						sColumnVal = StringReplace(sColumnVal, Chr$(34), "")

						sData = sData + " Col" + iColumn + " = " + Chr$(34) + sColumnVal + Chr$(34)
					Else
						sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
						Run Command (sCmd)
						Fetch First from TempCommon
						
						sCommonVal = TempCommon.Col1
						sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

						'If TableIsOpen("TempCommon") Then
						'	Close Table TempCommon
						'End If

						sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
					End If
				Case "First"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValFirst + Chr$(34)
				Case "Common"
					sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
					Run Command (sCmd)
					Fetch First from TempCommon
					
					sCommonVal = TempCommon.Col1
					sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

					'If TableIsOpen("TempCommon") Then
					'	Close Table TempCommon
					'End If

					sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
				Case "Range"
					If aColumnValues(iColumn).ValMin = aColumnValues(iColumn).ValMax Then
						sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
					Else
						sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + " - " + aColumnValues(iColumn).ValMax + Chr$(34)
					End If
				Case "Min"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
				Case "Max"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMax + Chr$(34)
				Case "Count"
					sData = sData + " Col" + iColumn + " = " + iRecs
				Case Else
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
			End Case
			
			sData = sData + ","
			
		Next
			
		sData = sData + " Temp = 0"
					
		'-------------------------------------------------
		' Create a buffered object from the 'Temp' objects
		'-------------------------------------------------
		If iBufferSize > 0 then
			sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
		Else
			sCmd = "Create Object As Union From " + sTempOutput + " Into Table " + sOutputName + sData
		End If
		Run Command (sCmd)
		
		'-------------------------------------------------
		' Increment the output counter
		'-------------------------------------------------
		iOutCount = iOutCount + 1

		'-------------------------------------------------
		' Delete all the original 'Temp' objects
		'-------------------------------------------------
		sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
		Run Command (sCmd)

		sCmd = "Delete From " + sTempOutput
		Run Command (sCmd)

		'-------------------------------------------------
		' Save the updates
		'-------------------------------------------------
		Set ProgressBars Off

		sCmd = "Commit Table " + sOutputName
		Run Command (sCmd)

		'-------------------------------------------------
		' Turn off FastEdit after updates
		'-------------------------------------------------
		Set Table sOutputName FastEdit Off
		Set Table sOutputName Undo On

		Set ProgressBars On

		Call MyPrint("Created " + FormatNumber$(iOutCount) + " buffered features")

	End If

CleanUp:

	OnError Goto 0
	
	'-------------------------------------------------
	' Close the temporary tables
	'-------------------------------------------------
	If TableIsOpen(sTempInput) Then
		Close Table sTempInput
	End If

	If TableIsOpen(sTempOutput) Then
		Close Table sTempOutput
	End If

	If TableIsOpen(sTempSelect) Then
		Close Table sTempSelect
	End If

	If TableIsOpen("TempInsert") Then
		Close Table TempInsert
	End If

	If TableIsOpen("TempCommon") Then
		Close Table TempCommon
	End If

	'-------------------------------------------------
	' Drop the temporary cluster table
	'-------------------------------------------------
	If TableIsOpen(sTempCluster) Then
		Drop Table sTempCluster
	End If

	'-------------------------------------------------
	' Close the the Selection table if it is
	' already/still open in the current MapInfo session
	'-------------------------------------------------
	If TableIsOpen("Selection") Then
		Close Table Selection
	End If

	'-------------------------------------------------
	' Unselect all records
	'-------------------------------------------------
	Run Menu command M_QUERY_UNSELECT

	'-------------------------------------------------
	' Drop the unique column
	'-------------------------------------------------
	If ColumnExists(sTableName, "RowInd") Then
		Call MyPrint("Removing temporary key from " + sTableName + " ...")
		Alter Table sTableName (Drop RowInd)
	End If

	'-------------------------------------------------
	' Add the table back to the top most map window
	' (if there is one), otherwise create a new map
	' window using the table
	'-------------------------------------------------
	If NumWindows() > 0 Then
		Add Map Layer sTableName
	Else
		Map From sTableName
	End If
		
	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Goto CleanUp

End Sub

Sub SetSymbology(sLocalName As String)
'***************************************************************
'* Retrieve the symbology styles and clauses from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLTableNode As MIXmlNode
	Dim hXMLSymbologyNode As MIXmlNode
	Dim hXMLSymbolNodeList As MIXMLNodeList
	Dim hXMLSymbolNode As MIXmlNode

	OnError Goto GetSymbologyError

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataBuffer.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Get a handle on the OutTable node
					'-------------------------------------------------
					hXMLTableNode = MIXmlSelectSingleNode(hXMLNode, "OutTable")

					'-------------------------------------------------
					' Get a handle on the symbology node for the table
					'-------------------------------------------------
					hXMLSymbologyNode = MIXmlSelectSingleNode(hXMLTableNode, "Symbology")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLSymbolNodeList = MIXMLGetChildList(hXMLSymbologyNode)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' applying the style using the SQL clauses
					'-------------------------------------------------
					Dim i As Integer
					i = 0
					Do while hXMLSymbolNode
						
						'-------------------------------------------------
						' Close the temporary NewStyle table if it is
						' already/still open in the current MapInfo session
						'-------------------------------------------------
						If TableIsOpen("NewStyle") Then
							Close Table NewStyle
						End If

						i = i + 1

						'-------------------------------------------------
						' Set the SQL clause used to retrieve the
						' required rows from the SQL table
						'-------------------------------------------------
						Dim sClause As String, sSQLClause As String
						sClause = GetSingleNodeValue(hXMLSymbolNode, "Clause")
						If sClause <> "" Then
						    sSQLClause = " And " + sClause
						Else
						   sSQLClause = ""
						End If

						'-------------------------------------------------
						' Get the type of object (i.e. Point, line or Region)
						'-------------------------------------------------
						Dim sObject As String
						sObject = GetSingleNodeValue(hXMLSymbolNode, "Object")

						'-------------------------------------------------
						' Select all the rows of the desired object type
						' matching the required SQL clause
						'-------------------------------------------------
						Dim sCmd As String
						sCmd = "Select * From " + sLocalName + " Where Str$(obj) Like ""%" + sObject + """" + sSQLClause + " Into NewStyle NoSelect"
						Run Command (sCmd)

						'-------------------------------------------------
						' Count the number of rows selected
						'-------------------------------------------------
						Dim iRows As Integer
						iRows = TableInfo(NewStyle, TAB_INFO_NROWS)

						If sClause <> "" Then
							Call MyPrint("Setting " + sObject + " style for " + FormatNumber$(iRows) + " rows where " + sClause)
						Else
							Call MyPrint("Setting " + sObject + " style for " + FormatNumber$(iRows) + " rows")
						End If

						'-------------------------------------------------
						' If any rows were selected then set the styles
						'-------------------------------------------------
						If iRows > 0 Then

							'-------------------------------------------------
							' Set the styles (depending on type of object)
							'-------------------------------------------------
							Dim sSymbol, sPen, sBrush As String
							Dim stlSymbol As Symbol
							Dim stlPen As Pen
							Dim stlBrush As Brush

							Do Case sObject
								Case "Point"
									sSymbol = GetSingleNodeValue(hXMLSymbolNode, "Symbol")
									stlSymbol = STLText2Symbol(sSymbol)
								Case "Line"
									sPen = GetSingleNodeValue(hXMLSymbolNode, "Pen")
									stlPen = STLText2Pen(sPen)
								Case "Region"
									sPen = GetSingleNodeValue(hXMLSymbolNode, "Pen")
									stlPen = STLText2Pen(sPen)
									sBrush = GetSingleNodeValue(hXMLSymbolNode, "Brush")
									stlBrush = STLText2Brush(sBrush)
								Case Else
							End Case

							'-------------------------------------------------
							' Alter the object style depending on the object
							' type and style type
							'-------------------------------------------------
							Do Case sObject
								Case "Point"
									Update NewStyle Set Obj = SetStylePoint(Obj, stlSymbol)
								Case "Line"
									Update NewStyle Set Obj = SetStyleLine(Obj, stlPen)
								Case "Region"
									Update NewStyle Set Obj = SetStylePolygon(Obj, stlPen, stlBrush)
								Case Else
							End Case

						End If

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					Loop

				End If

			End If

		Else

			Note "Error : " + MIGetErrorMessage()

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Close the temporary NewStyle table if it is
	' already/still open in the current MapInfo session
	'-------------------------------------------------
	If TableIsOpen("NewStyle") Then
		Close Table NewStyle
	End If

	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLSymbolNode Then Call MIXmlNodeDestroy(hXMLSymbolNode) End If
	If hXMLSymbolNodeList Then Call MIXmlNodeListDestroy(hXMLSymbolNodeList) End If
	If hXMLSymbologyNode Then Call MIXmlNodeDestroy(hXMLSymbologyNode) End If
	If hXMLTableNode Then Call MIXmlNodeDestroy(hXMLTableNode) End If

	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetSymbologyError:
	Note str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Function SetStylePoint(ByVal oObj As Object, ByVal stlSymbol As Symbol) As Object

	Alter Object oObj Info OBJ_INFO_SYMBOL, stlSymbol
	SetStylePoint = oObj

End Function

Function SetStyleLine(ByVal oObj As Object, ByVal stlPen As Pen) As Object

	Alter Object oObj Info OBJ_INFO_PEN, stlPen
	SetStyleLine = oObj

End Function

Function SetStylePolygon(ByVal oObj As Object, ByVal stlPen As Pen, ByVal stlBrush As Brush) As Object

	Alter Object oObj Info OBJ_INFO_PEN, stlPen
	Alter Object oObj Info OBJ_INFO_BRUSH, stlBrush
	SetStylePolygon = oObj

End Function

Sub AboutBox
'***************************************************************
'* Display the 'About' dialog box
'***************************************************************

	Dialog
		Title "About Data Buffer " + sVersion
		Width 230
		Height 105

	Control StaticText
		Title "This program will buffer and, optionally, consolidate"
		Position 10,10
	Control StaticText
		Title "records from one to more MapInfo layers and merge the"
		Position 10,20
	Control StaticText
		Title "results into a single new output layer."
		Position 10,30
	Control StaticText
		Title "Created by Andy Foy Consulting."
		Position 10,50
	Control StaticText
		Title "Copyright© 2016 - 2018 TVERC, SBIC."
		Position 10,60
	Control OKButton
		Position 185,85

End Sub

Sub MyPrint(ByVal sMsg As String)
'***************************************************************
'* Bespoke print function
'***************************************************************

	'-------------------------------------------------
	' Open the log file for output
	'-------------------------------------------------
	Open File sLogFileName For Append As #1

	'-------------------------------------------------
	' Write the message passed to the output file
	'-------------------------------------------------
	Print #1, FormatDate$(CurDate()) + " " + FormatTime$(CurTime(),"H:mm:ss") + " : " + sMsg

	'-------------------------------------------------
	' Close the output file
	'-------------------------------------------------
	Close File #1

End Sub

Sub PrintLogFile()
'***************************************************************
'* Open the log file in Notepad
'***************************************************************

	'-------------------------------------------------
	' Open the log file in Notepad
	'-------------------------------------------------
	Dim sCmd As String
	sCmd = "Run Program " +  + Chr$(34) + "NotePad.exe " + sLogFileName + Chr$(34)
	Run Command (sCmd)

End Sub

Sub egsit
'***************************************************************
'* Exit the program
'***************************************************************

	End Program

End Sub
