'* DataBuffer is a MapBasic tool to buffer and, optionally, consolidate
'* records from one or more MapInfo GIS layers and merge the results
'* into a single output MapInfo GIS layer.
'*
'* Copyright © 2016 TVERC
'* 
'* This file is part of the MapInfo tool 'DataBuffer'.
'* 
'* DataBuffer is free software: you can redistribute it and/or modify
'* it under the terms of the GNU General Public License as published by
'* the Free Software Foundation, either version 3 of the License, or
'* (at your option) any later version.
'* 
'* DataBuffer is distributed in the hope that it will be useful,
'* but WITHOUT ANY WARRANTY; without even the implied warranty of
'* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'* GNU General Public License for more details.
'* 
'* You should have received a copy of the GNU General Public License
'* along with DataBuffer.  If not, see <http://www.gnu.org/licenses/>.
'*
'***************************************************************
'* DataBuffer v1.02
'*
'* Buffers and (optionally) consolidates records from one or more
'* MapInfo GIS layers and merges the results into a new output
'* MapInfo GIS layer.
'*
'*
'* Created:			Andy Foy - February 2016
'* Last revised:	Andy Foy - March 2016
'*
'* *****************  Version 1.02  *****************
'* Author: Andy Foy		Date: 09/03/2016
'* A. Ask user if they want to keep the dialog open.
'* B. Open log file using Notepad.exe.
'* 
'* *****************  Version 1.01  *****************
'* Author: Andy Foy		Date: 24/02/2016
'* A. Initial version of tool.
'* 
'***************************************************************
Include "DataBuffer.def"

Sub Main
'***************************************************************
'* Main sub-routine
'***************************************************************

	'-------------------------------------------------
	' Set the version number
	'-------------------------------------------------
	sVersion = "1.02"

	'-------------------------------------------------
	' Create a new menu
	'-------------------------------------------------
	Create Menu "&Data Buffer" As
	   "&Run Data Buffer ..." Calling OpenDialog,
	   "(-",
	   "&About Data Buffer ..." Calling AboutBox,
	   "E&xit Data Buffer" Calling egsit

	'-------------------------------------------------
	' Add the new menu item to the Tools menu
	'-------------------------------------------------
	Alter Menu "Tools" Add
		"Data Buffer" As "Data Buffer"

	Exit Sub

End Sub

Sub GetDefaultValues
'***************************************************************
'* Retrieve all the default values from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLFilesNodeList As MIXMLNodeList
	Dim hXMLFilesNodeParent As MIXmlNode
	Dim hXMLFilesNode As MIXmlNode
	Dim hXMLColumnsNode As MIXmlNode

	OnError Goto GetVariablesError

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataBuffer.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
				If hXMLNode Then
	
					'-------------------------------------------------
					' Load the default values from the child nodes
					' under the DataBuffer node
					'-------------------------------------------------
					' File path for storing the log file
					Dim sLogFilePath As string
					sLogFilePath = GetSingleNodeValue(hXMLNode, "LogFilePath")
					sLogFileName = sLogFilePath & "\DataBuffer_" & sUserID & ".log"

					' Default file path to store extracts in sub-folders
					sDefaultPath = GetSingleNodeValue(hXMLNode, "DefaultPath")

					' Name of the table to create
					sOutTableName = GetSingleNodeValue(hXMLNode, "OutTableName")

					' Definitions of the columns in the new table
					sOutColumnDefs = GetSingleNodeValue(hXMLNode, "OutColumnDefs")

					' Coordinate system to be used for mapping
					sCoordSys = GetSingleNodeValue(hXMLNode, "CoordinateSystem")

					'-------------------------------------------------
					' Get a handle on the input tables node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "InTables")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLFilesNodeParent)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the values in an array
					'-------------------------------------------------
					Dim i As Integer
					i = 0
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the table node
						aInTables(i).Node = GetNodeName(hXMLFilesNode)

						' Name of the MapInfo table to be input
						aInTables(i).TableName = GetSingleNodeValue(hXMLFilesNode, "TableName")

						' The columns to read from the input table
						aInTables(i).Columns = GetSingleNodeValue(hXMLFilesNode, "Columns")

						' The column sort order to read the input table
						aInTables(i).SortOrder = GetSingleNodeValue(hXMLFilesNode, "SortOrder")

						' The size of the buffer to apply to the records
						aInTables(i).BufferSize = GetSingleNodeValue(hXMLFilesNode, "BufferSize")

						' The proximity of records to be dissolved together
						aInTables(i).DissolveSize = GetSingleNodeValue(hXMLFilesNode, "DissolveSize")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim aInTables(i)

					'-------------------------------------------------
					' Get a handle on the output table node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "OutTable")

					'-------------------------------------------------
					' Get a handle on the symbology node for the table
					'-------------------------------------------------
					hXMLColumnsNode = MIXmlSelectSingleNode(hXMLFilesNodeParent, "Columns")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLColumnsNode)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the values in an array
					'-------------------------------------------------
					i = 0
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the column node
						aOutColumns(i).Node = GetNodeName(hXMLFilesNode)

						' Name of the column to be output to the new buffered layer
						aOutColumns(i).ColumnName = GetSingleNodeValue(hXMLFilesNode, "ColumnName")

						' Type of column to be output to the new buffered layer
						aOutColumns(i).ColumnType = GetSingleNodeValue(hXMLFilesNode, "ColumnType")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim aOutColumns(i)

				End If

			End If

		Else

			Note "Error : " + MIGetErrorMessage()

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLColumnsNode Then Call MIXmlNodeDestroy(hXMLColumnsNode) End If
	If hXMLFilesNode Then Call MIXmlNodeDestroy(hXMLFilesNode) End If
	If hXMLFilesNodeList Then Call MIXmlNodeListDestroy(hXMLFilesNodeList) End If
	If hXMLFilesNodeParent Then Call MIXmlNodeDestroy(hXMLFilesNodeParent) End If
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetVariablesError:
	Note str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Sub OpenDialog
'***************************************************************
'* Create the user dialog window
'***************************************************************

	'-------------------------------------------------
	' Trap errors
	'-------------------------------------------------
    OnError Goto ErrorTrap

	'-------------------------------------------------
	' Get the current user ID
	'-------------------------------------------------
	sUserID = GetUserID()
	sUserID = StringReplace(sUserID, " ", "_")
	sUserID = StringReplace(sUserID, ".", "_")

	'-------------------------------------------------
	' Retrieve the default values from the config file
	'-------------------------------------------------
	Call GetDefaultValues

	'-------------------------------------------------
	' Build a new dialog window
	'-------------------------------------------------
	Dialog
		Title "Data Buffer " + sVersion
		Width 300
		Height 260
		Position 50, 70
		Calling DialogSetup

	'-------------------------------------------------
	' Add a input table listbox
	'-------------------------------------------------
	Control StaticText Title "Input Tables:"
		Position 10, 10
	Control MultiListBox
		ID 1
		Title ""
		Position 10, 20
		Height 170
		Width 170

	'-------------------------------------------------
	' Add a checkbox for clearing the log file
	'-------------------------------------------------
	Control CheckBox
		ID 6
		Title "Clear log file?"
		Position 10,230
		Value TRUE
		'Into bClearLog

	'-------------------------------------------------
	' Add Ok and cancel buttons
	'-------------------------------------------------
	Control CancelButton
		Position 205,240
		Width 40
	Control Button
		Title "Ok"
		Position 250,240
		Width 40
		Calling CheckSelection

Done:
	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Resume Done

End Sub

Sub DialogSetup
'***************************************************************
' Setup the dialog window listboxes
'***************************************************************

	'-------------------------------------------------
	' Clear the Message window and close it
	'-------------------------------------------------
	Print(chr$(12))
	Close Window Message

	'-------------------------------------------------
	' Store the names of any tables not open
	'-------------------------------------------------
	Dim sClosedTables As String, iClosedCount as Integer
	sClosedTables = ""
	iClosedCount = 0
	
	'-------------------------------------------------
	' Loop through all the input tables listed in the
	' config file and add them to the input Table list
	' if they are open in MapInfo
	'-------------------------------------------------
	Dim i, j As Integer
	Dim aOpenTables(99) As String
	j = 0
	For i = 1 to UBound(aInTables)

		'-------------------------------------------------
		' Concatenate all the Map tables into an array
		'-------------------------------------------------
		If TableIsOpen(aInTables(i).TableName) Then
			j = j + 1
			aOpenTables(j) = aInTables(i).TableName
			aInTablesOpen(j).Node = aInTables(i).Node
			aInTablesOpen(j).TableName = aInTables(i).TableName
			aInTablesOpen(j).Columns = aInTables(i).Columns
			aInTablesOpen(j).SortOrder = aInTables(i).SortOrder
			aInTablesOpen(j).BufferSize = aInTables(i).BufferSize
			aInTablesOpen(j).DissolveSize = aInTables(i).DissolveSize
		Else
			'-------------------------------------------------
			' Store the name of the closed table
			'-------------------------------------------------
			sClosedTables = sClosedTables + Chr$(13) + aInTables(i).TableName
			iClosedCount = iClosedCount + 1
		End If

	Next

	Redim aInTablesOpen(j)
	Redim aOpenTables(j)

	'-------------------------------------------------
	' Update the input table list to show the list
	' of open tables
	'-------------------------------------------------
	Alter Control 1 Title FROM Variable aOpenTables

	'-------------------------------------------------
	' Warn the user of the closed tables
	'-------------------------------------------------
	If iClosedCount > 0 Then
		If iClosedCount = 1 Then
			Note "Warning: the following table is not open ..." + Chr$(13) + sClosedTables
		Else
			Note "Warning: " + iClosedCount + " tables are not open, including ..." + Chr$(13)+ sClosedTables
		End If
	End If

End Sub

Sub CheckSelection
'***************************************************************
'* Check the user's selections and process according
'***************************************************************

	'-------------------------------------------------
	' Store the dialog variables
	'-------------------------------------------------
	bClearLog = ReadControlValue(6)

	'-------------------------------------------------
	' Check if the user has selected at least one input
	' table
	'-------------------------------------------------
	iInTable = ReadControlValue(1)
	if iInTable = 0 then
		Note "No input tables have been selected!"
		Exit Sub
	End If

	'-------------------------------------------------
	' Reset the global variables
	'-------------------------------------------------
	iInTableTot = 0
	iInTableCnt = 0

	'-------------------------------------------------
	' Count the number of input tables to process
	'-------------------------------------------------
	Do While iInTable > 0
	
		'-------------------------------------------------
		' Increment the counters
		'-------------------------------------------------
		iInTableTot = iInTableTot + 1

		aInTablesSelected(iInTableTot).Node = aInTablesOpen(iInTable).Node
		aInTablesSelected(iInTableTot).TableName = aInTablesOpen(iInTable).TableName
		aInTablesSelected(iInTableTot).Columns = aInTablesOpen(iInTable).Columns
		aInTablesSelected(iInTableTot).SortOrder = aInTablesOpen(iInTable).SortOrder
		aInTablesSelected(iInTableTot).BufferSize = aInTablesOpen(iInTable).BufferSize
		aInTablesSelected(iInTableTot).DissolveSize = aInTablesOpen(iInTable).DissolveSize

		'-------------------------------------------------
		' Read the next input table selected in the list
		'-------------------------------------------------
		iInTable = ReadControlValue(1)

	Loop

	'-------------------------------------------------
	' Prompt the user for the output file destination
	'-------------------------------------------------
	Dim sOutputFile As String
	sOutputFile = FileSaveAsDlg(sDefaultPath, "", "TAB", "Select where to save the output file")

	if sOutputFile = "" then
		Call MyPrint("No output file selected - process cancelled")
		Note "No output file selected - process cancelled"
		Exit Sub
	End If

	'-------------------------------------------------
	' Get the path and name of the selected output file
	'-------------------------------------------------
	sOutputPath = PathToDirectory$(sOutputFile)
	sOutputName = PathToFileName$(sOutputFile)

	'-------------------------------------------------
	' Check the selected directory already exists
	'-------------------------------------------------
	Dim iSuccess, iSecurity As Integer
	iSecurity = 0
	iSuccess = SetCurrentDirectory(sOutputPath)
	if iSuccess = 0 Then
		Call MyPrint("Output folder does not exist - process cancelled")
		Note "Output folder does not exist - process cancelled"
		Exit Sub
	End If

	'-------------------------------------------------
	' Check the selected file name has the correct
	' extension
	'-------------------------------------------------
	if UCase$(Right$(sOutputName, 3)) <> UCase$("TAB") Then
		Call MyPrint("Output file has incorrect extension - process cancelled")
		Note "Output file has incorrect extension - process cancelled"
		Exit Sub
	End If

	'-------------------------------------------------
	' Remove the file extension from the output file name
	'-------------------------------------------------
	sOutputName = Left$(sOutputName, Len(sOutputName) - 4)

	Call MyPrint("Output File = '" + sOutputFile + "'")

	'-------------------------------------------------
	' Clear the log file (if it exists)
	'-------------------------------------------------
	If bClearLog = True Then
		If FileExists(sLogFileName) Then
			Kill sLogFileName
		End If

	End If

	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("Process started!")
	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("")

	'-------------------------------------------------
	' Call the subroutine to create the new
	' output buffer table.
	'-------------------------------------------------
	Call CreateBufferTable(sOutputPath, sOutputName)
	Dim lResponse As Logical
	If sOutputName = "" Then
		Call MyPrint("Error creating output buffer table.")
		Call MyPrint("")
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process stopped!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Process stopped!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
		Goto Response
	End If

	'-------------------------------------------------
	' Process the selected tables one by one
	'-------------------------------------------------
	iInTableCnt = 1
	ProgressBar "Processing " + iInTableTot + " input tables ..."
		Calling ProcessTables
		Range iInTableTot

	If CommandInfo(CMD_INFO_STATUS) Then
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process completed!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Processing complete!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
	Else
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process interrupted by user!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Processing interrupted!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
		Goto Response
	End If

	Alter Table sOutputName (Drop Temp)

	'-------------------------------------------------
	' Drop the temporary column
	'-------------------------------------------------
	Set ProgressBars Off

	'-------------------------------------------------
	' Pack the output table
	'-------------------------------------------------
	Pack Table sOutputName Graphic Data

	Set ProgressBars On

	'-------------------------------------------------
	' Add the output table to the top most map window
	' (if there is one), otherwise create a new map
	' window using the table
	'-------------------------------------------------
	If NumWindows() > 0 Then
		Add Map Layer sOutputName
	Else
		Map From sOutputName
	End If

Response:
	If lResponse = True Then
		'-------------------------------------------------
		' Close the dialog
		'-------------------------------------------------
		Dialog Remove

	End If

	'-------------------------------------------------
	' Display the log file in the message window
	'-------------------------------------------------
	Call PrintLogFile

End Sub

Sub CreateBufferTable (sOutputPath As String, sOutputName As String)
'*************************************************
'* Routine to create a new output buffer table.
'*************************************************

	Call MyPrint("Creating output buffer table ...")

	'-------------------------------------------------
	' Replace any spaces in the output table name with
	' underscores and remove hyphens
	'-------------------------------------------------
	sOutputName = StringReplace(sOutputName, " ", "_")
	sOutputName = StringReplace(sOutputName, "-", "")

	'-------------------------------------------------
	' Check if an existing output table is
	' already/still open and close it if it is
	'-------------------------------------------------
	If TableIsOpen(sOutputName) Then
		Call MyPrint("Closing output table ...")
		Close Table sOutputName
	End If

	OnError Goto CreateError

	'-------------------------------------------------
	' Create new output table"
	'-------------------------------------------------
	Dim sCmd As String
	sCmd = "Create Table " + Chr$(34) + sOutputName + Chr$(34) + " (" + sOutColumnDefs + ", Temp Integer) file " + Chr$(34) + sOutputPath + sOutputName + ".tab" + Chr$(34)
	+ " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
	Run Command (sCmd)

	'-------------------------------------------------
	' Make output table mappable
	'-------------------------------------------------
	sCmd = "Create Map For " + sOutputName + " CoordSys " + sCoordSys
	Run Command (sCmd)

'	'-------------------------------------------------
'	' Find the layer number of the search table by
'	' looking through all the windows until it is
'	' found
'	'-------------------------------------------------
'	Dim iNumWindows As Integer
'	iNumWindows = UBound(aWindowId)
'	Dim iWindowNum As Integer
'	For iWindowNum = 1 to iNumWindows
'		Dim iNumTables As Integer
'		Dim iNumSearchTable as Integer
'		iNumTables = MapperInfo(aWindowId(iWindowNum), MAPPER_INFO_LAYERS)
'		For iNumSearchTable = 1 to iNumTables
'			If LayerInfo(aWindowId(iWindowNum),iNumSearchTable, LAYER_INFO_NAME) = sSearchTable Then
'				Goto EditLayer
'			End If
'		Next
'	Next
'
'EditLayer:
'	'-------------------------------------------------
'	' Make the layer editable
'	'-------------------------------------------------
'	If LayerInfo(aWindowId(iWindowNum),iNumSearchTable,LAYER_INFO_EDITABLE) = False Then
'		Set Map Window aWindowId(iWindowNum) Layer iNumSearchTable Editable On
'	End If

	Call MyPrint("Created output buffer table.")

	Exit Sub

CreateError:
	sOutputName = ""

End Sub

Sub ProcessTables()
'***************************************************************
'* Process the input table
'***************************************************************

	Dim sNodeName, sTableName, sColumns, sSortOrder As String
	Dim iBufferSize, iDissolveSize As Integer
	sNodeName = aInTablesSelected(iInTableCnt).Node
	sTableName = aInTablesSelected(iInTableCnt).TableName
	sColumns = aInTablesSelected(iInTableCnt).Columns
	sSortOrder = aInTablesSelected(iInTableCnt).SortOrder
	iBufferSize = aInTablesSelected(iInTableCnt).BufferSize
	iDissolveSize = aInTablesSelected(iInTableCnt).DissolveSize

	Call MyPrint("Processing table " + sTableName + "(" + iInTableCnt + " of " + iInTableTot + ") ...")

	'-------------------------------------------------
	' Call the subroutine to select the records from
	' the selected table for the selected partner
	'-------------------------------------------------
	Call BufferRecords(sTableName, sColumns, sSortOrder, iBufferSize, iDissolveSize)

	Call MyPrint("Completed process " + iInTableCnt + " of " + iInTableTot + ".")
	Call MyPrint("")

	'-------------------------------------------------
	' Increment the progress bar to show progress
	'-------------------------------------------------
	ProgressBar = iInTableCnt

	'-------------------------------------------------
	' Go to the next selection in the list
	'-------------------------------------------------
	iInTableCnt = iInTableCnt + 1
	If iInTableCnt > iInTableTot Then
		'-------------------------------------------------
		' Halt processing
		'-------------------------------------------------
		ProgressBar = -1
	End If

End Sub

Sub BufferRecords
	(sTableName As String,
	sColumns As String,
	sSortOrder As String,
	iBufferSize As Integer,
	iDissolveSize As Integer)
'*************************************************
'* Routine to select the records from the
'* MapInfo table name passed in the call, buffer
'* and/or dissolve them and copy them to the
'* output table.
'*************************************************

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Setup the temporary table names
	'-------------------------------------------------
	Dim sTempInput, sTempOutput As String
	sTempInput = "TempInput"
	sTempOutput = "TempOutput"

	Dim sTempSelect As String
	sTempSelect = "TempSelect"

	Dim sTempCluster As String
	sTempCluster = "TempCluster"

	'-------------------------------------------------
	' Check if the temporary tables are already/still
	' open and close them if it is
	'-------------------------------------------------
	If TableIsOpen(sTempInput) Then
		Call MyPrint("Closing temporary table TempInput ...")
		Close Table sTempInput
	End If

	If TableIsOpen(sTempOutput) Then
		Call MyPrint("Closing temporary table TempOutput ...")
		Close Table sTempOutput
	End If

	If TableIsOpen(sTempSelect) Then
		Call MyPrint("Closing temporary table TempSelect ...")
		Close Table sTempSelect
	End If

	If TableIsOpen(sTempCluster) Then
		Call MyPrint("Closing temporary table TempCluster ...")
		Close Table sTempCluster
	End If

	'-------------------------------------------------
	' Check if the records need to be clustered
	'-------------------------------------------------
	Dim bCluster As Logical, iClusterSize As Integer
	iClusterSize = (Int(iDissolveSize) / 2) - 1
	If iClusterSize > 0 Then
		bCluster = True
	End If

	'-------------------------------------------------
	' If the records need to be clustered (dissolved)
	'-------------------------------------------------
	If bCluster Then

		'-------------------------------------------------
		' Create a new cluster table for the input records
		' if they are to be dissolved
		'-------------------------------------------------
		Dim sCmd As String
		sCmd = "Create Table " + Chr$(34) + sTempCluster + Chr$(34) + " (ClusterID Integer) file " + Chr$(34) + sOutputPath + "\" + sTempCluster + ".tab" + Chr$(34) + " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Make the cluster table mappable
		'-------------------------------------------------
		sCmd = "Create Map For " + sTempCluster + " CoordSys " + sCoordSys
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Create a single clustered object
		'-------------------------------------------------
		sCmd = "Create Object As Buffer From " + sTableName + " Width " + iClusterSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sTempCluster
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Disaggregate the clustered object
		'-------------------------------------------------
		sCmd = "Objects Disaggregate Into Table " + sTempCluster
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Update the ClusterId in the table
		'-------------------------------------------------
		sCmd = "Update " + sTempCluster + " Set ClusterID = RowID"
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Save the clustered objects
		'-------------------------------------------------
		sCmd = "Commit Table " + sTempCluster
		Run Command (sCmd)
		
		'-------------------------------------------------
		' Close the latest query table
		'-------------------------------------------------
		Dim t As SmallInt
		For t = NumTables() to 1 Step -1
			If TableInfo(t, TAB_INFO_TEMP) Then
				Close Table TableInfo(t, TAB_INFO_NAME)
				Exit For
			End If
		Next

	End If

	'-------------------------------------------------
	' Select the required columns from the input
	' table
	'-------------------------------------------------
	Call MyPrint("Selecting feature from " + sTableName + " ...")

	'-------------------------------------------------
	' If the records need to be clustered (dissolved)
	' then include the cluster ID from the overlapping
	' cluster
	'-------------------------------------------------
	If bCluster Then
		sCmd = "Select " + sColumns + ", Obj, ClusterID From " + sTableName + ", " + sTempCluster + " Where " + sTableName + ".Obj Within " + sTempCluster + ".Obj Order By ClusterID, " + sSortOrder + " Into " + sTempInput + " NoSelect"
	Else
		sCmd = "Select " + sColumns + ", Obj, 0" + Chr$(34) + "ClusterID" + Chr$(34) + " From " + sTableName + " Order By " + sSortOrder + " Into " + sTempInput + " NoSelect"
	End If
	Run Command (sCmd)

	'-------------------------------------------------
	' Count the number of rows selected
	'-------------------------------------------------
	Dim iRows As Integer
	iRows = TableInfo(sTempInput, TAB_INFO_NROWS)

	Call MyPrint("Buffering " + FormatNumber$(iRows) + " rows ...")

	'-------------------------------------------------
	' Reset the column values
	'-------------------------------------------------
	Dim iColumn As Integer
	For iColumn = 1 to UBound(aOutColumns)
		aColumnValues(iColumn).ValKey = ""
		aColumnValues(iColumn).ValMin = ""
		aColumnValues(iColumn).ValMax = ""
		aColumnValues(iColumn).ValFirst = ""
		aColumnValues(iColumn).ValCommon = ""
	Next

	'-------------------------------------------------
	' Turn on FastEdit to speed up the updates
	'-------------------------------------------------
	Set Table sOutputName FastEdit On

	'-------------------------------------------------
	' If any rows were selected then set the object
	'-------------------------------------------------
	If iRows > 0 Then

		'-------------------------------------------------
		' Set the coordinate system to that of the table
		'-------------------------------------------------
		Set Coordsys table TempInput

		'-------------------------------------------------
		' Fetch the first of the selected rows
		'-------------------------------------------------
		Fetch First from TempInput

		Dim sColumn As Alias, sColumnVal As String
		Dim bSame As Logical
		bSame = False
		
		Dim iLastClusterId As Integer
		iLastClusterId = 0
	
		'-------------------------------------------------
		' Loop through all the selected rows buffer the
		' spatial objects
		'-------------------------------------------------
		Dim iRow as Integer
		iRow = 1
		Do while iRow <= iRows

			'-------------------------------------------------
			' Loop through every column in the output table
			' to check if the key columns have changed
			'-------------------------------------------------
			For iColumn = 1 to UBound(aOutColumns)
				
				'-------------------------------------------------
				' Set an alias for the column
				'-------------------------------------------------
				sColumn = "TempInput.Col" + iColumn
				sColumnVal = sColumn
				If Instr(1, sColumnVal, Chr$(34)) > 0 Then
					
					sColumnVal = StringReplace(sColumnVal, Chr$(34), "")

				End If
				
				'-------------------------------------------------
				' Check if the key columns have changed from the
				' last record
				'-------------------------------------------------
				Do Case aOutColumns(iColumn).ColumnType
					Case "Key"
						If aColumnValues(iColumn).ValKey <> sColumnVal Then
							bSame = False
						End If
					Case "Cluster"
						If aColumnValues(iColumn).ValKey <> sColumnVal And bCluster = False Then
							bSame = False
						End If
					Case Else
				End Case
			Next

			'-------------------------------------------------
			' If the key columns have not changed and this is
			' the same cluster
			'-------------------------------------------------
			If bSame = True And iLastClusterId = TempInput.ClusterID Then

				'-------------------------------------------------
				' Loop through every column in the output table
				' to update the values
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Set an alias for the column
					'-------------------------------------------------
					sColumn = "TempInput.Col" + iColumn
					sColumnVal = sColumn

					If Instr(1, sColumnVal, Chr$(34)) > 0 Then
						
						sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
	
					End If
					
					'-------------------------------------------------
					' Check if the range columns have changed
					'-------------------------------------------------
					Do Case aOutColumns(iColumn).ColumnType
						Case "Range"
							If sColumnVal < aColumnValues(iColumn).ValMin Then
								aColumnValues(iColumn).ValMin = sColumnVal
							End If
							If sColumnVal > aColumnValues(iColumn).ValMax Then
								aColumnValues(iColumn).ValMax = sColumnVal
							End If
						Case Else
					End Case
				Next		

			'-------------------------------------------------
			' If the key columns have changed
			'-------------------------------------------------
			Else

				If iRow > 1 Then

					'-------------------------------------------------
					' Select all the 'Temp' objects
					'-------------------------------------------------
					sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
					Run Command (sCmd)

					'-------------------------------------------------
					' Loop through every column in the output table
					' to set the values
					'-------------------------------------------------
					Dim sData As String
					sData = " Data "
					For iColumn = 1 to UBound(aOutColumns)
	
						Do Case aOutColumns(iColumn).ColumnType
							Case "Key"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
							Case "Cluster"
								If bCluster = False Then
									sColumnVal = aColumnValues(iColumn).ValKey
									sColumnVal = StringReplace(sColumnVal, Chr$(34), "")

									sData = sData + " Col" + iColumn + " = " + Chr$(34) + sColumnVal + Chr$(34)
								Else
									sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
									Run Command (sCmd)
									Fetch First from TempCommon
									
									Dim sCommonVal As String
									sCommonVal = TempCommon.Col1
									sCommonVal = StringReplace(sCommonVal, Chr$(34), "")
	
									If TableIsOpen("TempCommon") Then
										Close Table TempCommon
									End If
	
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
								End If
							Case "First"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValFirst + Chr$(34)
							Case "Common"
								sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
								Run Command (sCmd)
								Fetch First from TempCommon
								
								sCommonVal = TempCommon.Col1
								sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

								If TableIsOpen("TempCommon") Then
									Close Table TempCommon
								End If

								sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
							Case "Range"
								If aColumnValues(iColumn).ValMin = aColumnValues(iColumn).ValMax Then
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
								Else
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + " - " + aColumnValues(iColumn).ValMax + Chr$(34)
								End If
							Case Else
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
						End Case
						
						sData = sData + ","
						
					Next
						
					sData = sData + " Temp = 0"
						
					'-------------------------------------------------
					' Create a buffered object or objects from the
					' 'Temp' objects
					'-------------------------------------------------
					If bCluster Then
						sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
					Else
						sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
					End If
					Run Command (sCmd)

					'-------------------------------------------------
					' Delete all the original 'Temp' objects
					'-------------------------------------------------
					sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
					Run Command (sCmd)

					sCmd = "Delete From " + sTempOutput
					Run Command (sCmd)

				End If

				'-------------------------------------------------
				' Loop through every column in the output table
				' to set the values
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Set an alias for the column
					'-------------------------------------------------
					sColumn = "TempInput.Col" + iColumn
					sColumnVal = sColumn
					sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
	
					'-------------------------------------------------
					' Set the column values
					'-------------------------------------------------
					aColumnValues(iColumn).ValKey = sColumnVal
					aColumnValues(iColumn).ValMin = sColumnVal
					aColumnValues(iColumn).ValMax = sColumnVal
					aColumnValues(iColumn).ValFirst = sColumnVal
					aColumnValues(iColumn).ValCommon = sColumnVal
					
					'-------------------------------------------------
					' Store the cluster ID
					'-------------------------------------------------
					iLastClusterId = TempInput.ClusterID
					
				Next
				
				bSame = True
				
			End If

			'-------------------------------------------------
			' Copy the record into the output table as a
			' 'Temp' object
			'-------------------------------------------------
			sCmd = "Select " + sColumns + ", 1 " + Chr$(34) + "Temp" + Chr$(34) + ", Obj From " + sTempInput + " Where RowID = " + iRow + " Into TempInsert"
			Run Command (sCmd)
			sCmd = "Insert Into " + sOutputName + " (" + sColumns + ", Temp, Obj) Select * From TempInsert"
			Run Command (sCmd)

			If TableIsOpen("TempInsert") Then
				Close Table TempInsert
			End If

			'-------------------------------------------------
			' Fetch the next of the selected rows
			'-------------------------------------------------
			Fetch Next From sTempInput
			iRow = iRow + 1

		Loop

		'-------------------------------------------------
		' Process the final row ...
		'-------------------------------------------------

		'-------------------------------------------------
		' Select all the 'Temp' objects
		'-------------------------------------------------
		sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
		Run Command (sCmd)

		'-------------------------------------------------
		' Loop through every column in the output table
		' to set the values
		'-------------------------------------------------
		sData = " Data "
		For iColumn = 1 to UBound(aOutColumns)

			Do Case aOutColumns(iColumn).ColumnType
				Case "Key"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
				Case "Cluster"
					If bCluster = False Then
						sColumnVal = aColumnValues(iColumn).ValKey
						sColumnVal = StringReplace(sColumnVal, Chr$(34), "")

						sData = sData + " Col" + iColumn + " = " + Chr$(34) + sColumnVal + Chr$(34)
					Else
						sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
						Run Command (sCmd)
						Fetch First from TempCommon
						
						sCommonVal = TempCommon.Col1
						sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

						If TableIsOpen("TempCommon") Then
							Close Table TempCommon
						End If

						sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
					End If
				Case "First"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValFirst + Chr$(34)
				Case "Common"
					sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
					Run Command (sCmd)
					Fetch First from TempCommon
					
					sCommonVal = TempCommon.Col1
					sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

					If TableIsOpen("TempCommon") Then
						Close Table TempCommon
					End If

					sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
				Case "Range"
					If aColumnValues(iColumn).ValMin = aColumnValues(iColumn).ValMax Then
						sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
					Else
						sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + " - " + aColumnValues(iColumn).ValMax + Chr$(34)
					End If
				Case Else
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
			End Case
			
			sData = sData + ","
			
		Next
			
		sData = sData + " Temp = 0"
					
		'-------------------------------------------------
		' Create a buffered object or objects from the
		' 'Temp' objects
		'-------------------------------------------------
		If bCluster Then
			sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
		Else
			sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
		End If
		Run Command (sCmd)

		'-------------------------------------------------
		' Delete all the original 'Temp' objects
		'-------------------------------------------------
		sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
		Run Command (sCmd)

		sCmd = "Delete From " + sTempOutput
		Run Command (sCmd)

		'-------------------------------------------------
		' Save the updates
		'-------------------------------------------------
		Set ProgressBars Off

		sCmd = "Commit Table " + sOutputName
		Run Command (sCmd)

		'-------------------------------------------------
		' Turn off FastEdit after updates
		'-------------------------------------------------
		Set Table sOutputName FastEdit Off

		Set ProgressBars On

	End If

CleanUp:
	'-------------------------------------------------
	' Close the temporary tables
	'-------------------------------------------------
	If TableIsOpen(sTempInput) Then
		Close Table sTempInput
	End If

	If TableIsOpen(sTempOutput) Then
		Close Table sTempOutput
	End If

	If TableIsOpen(sTempSelect) Then
		Close Table sTempSelect
	End If

	'-------------------------------------------------
	' Drop the temporary cluster table
	'-------------------------------------------------
	If TableIsOpen(sTempCluster) Then
		Drop Table sTempCluster
	End If

	'-------------------------------------------------
	' Close the the Selection table if it is
	' already/still open in the current MapInfo session
	'-------------------------------------------------
	If TableIsOpen("Selection") Then
		Close Table Selection
	End If

	'-------------------------------------------------
	' Unselect all records
	'-------------------------------------------------
	Run Menu command M_QUERY_UNSELECT

	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Exit Sub

End Sub

Sub SetSymbology(sNodeName as String, sLocalName As String, sShortName As String)
'***************************************************************
'* Retrieve the symbology styles and clauses from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLSQLTableNode As MIXmlNode
	Dim hXMLTableNode As MIXmlNode
	Dim hXMLSymbologyNode As MIXmlNode
	Dim hXMLSymbolNodeList As MIXMLNodeList
	Dim hXMLSymbolNode As MIXmlNode

	OnError Goto GetSymbologyError

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataBuffer.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Get a handle on the OutTable node
					'-------------------------------------------------
					hXMLSQLTableNode = MIXmlSelectSingleNode(hXMLNode, "OutTable")

					'-------------------------------------------------
					' Get a handle on the current SQL table node
					'-------------------------------------------------
					hXMLTableNode = MIXmlSelectSingleNode(hXMLSQLTableNode, sNodeName)

					'-------------------------------------------------
					' Get a handle on the symbology node for the table
					'-------------------------------------------------
					hXMLSymbologyNode = MIXmlSelectSingleNode(hXMLTableNode, "Symbology")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLSymbolNodeList = MIXMLGetChildList(hXMLSymbologyNode)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' applying the style using the SQL clauses
					'-------------------------------------------------
					Dim i As Integer
					i = 0
					Do while hXMLSymbolNode
						
						'-------------------------------------------------
						' Close the temporary NewStyle table if it is
						' already/still open in the current MapInfo session
						'-------------------------------------------------
						If TableIsOpen("NewStyle") Then
							Close Table NewStyle
						End If

						i = i + 1

						'-------------------------------------------------
						' Set the SQL clause used to retrieve the
						' required rows from the SQL table
						'-------------------------------------------------
						Dim sClause As String
						sClause = GetSingleNodeValue(hXMLSymbolNode, "Clause")
						If sClause <> "" Then
						    sClause = " And " + sClause
						End If

						'-------------------------------------------------
						' Get the type of object (i.e. Point or Region)
						'-------------------------------------------------
						Dim sObject As String
						sObject = GetSingleNodeValue(hXMLSymbolNode, "Object")

						'-------------------------------------------------
						' Select all the rows of the desired object type
						' matching the required SQL clause
						'-------------------------------------------------
						Dim sCmd As String
						sCmd = "Select * From " + sLocalName + "_" + sShortName + " Where Str$(obj) = """ + sObject + "" + sClause + " Into NewStyle NoSelect"
						Run Command (sCmd)

						'-------------------------------------------------
						' Count the number of rows selected
						'-------------------------------------------------
						Dim iRows As Integer
						iRows = TableInfo(NewStyle, TAB_INFO_NROWS)

						Call MyPrint("Setting " + sObject + " style for " + FormatNumber$(iRows) + " rows where " + sClause)

						'-------------------------------------------------
						' If any rows were selected then set the styles
						'-------------------------------------------------
						If iRows > 0 Then

							'-------------------------------------------------
							' Set the styles (depending on type of object)
							'-------------------------------------------------
							Dim sSymbol, sPen, sBrush As String
							Dim stlSymbol As Symbol
							Dim stlPen As Pen
							Dim stlBrush As Brush

							Do Case sObject
								Case "Point"
									sSymbol = GetSingleNodeValue(hXMLSymbolNode, "Symbol")
									stlSymbol = STLText2Symbol(sSymbol)
								Case "Region"
									sPen = GetSingleNodeValue(hXMLSymbolNode, "Pen")
									stlPen = STLText2Pen(sPen)
									sBrush = GetSingleNodeValue(hXMLSymbolNode, "Brush")
									stlBrush = STLText2Brush(sBrush)
								Case Else
							End Case

							'-------------------------------------------------
							' Alter the object style depending on the object
							' type and style type
							'-------------------------------------------------
							Do Case sObject
								Case "Point"
									Update NewStyle Set Obj = SetStylePoint(Obj, stlSymbol)
								Case "Region"
									Update NewStyle Set Obj = SetStylePolygon(Obj, stlPen, stlBrush)
								Case Else
							End Case

						End If

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					Loop

				End If

			End If

		Else

			Note "Error : " + MIGetErrorMessage()

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLSymbolNode Then Call MIXmlNodeDestroy(hXMLSymbolNode) End If
	If hXMLSymbolNodeList Then Call MIXmlNodeListDestroy(hXMLSymbolNodeList) End If
	If hXMLSymbologyNode Then Call MIXmlNodeDestroy(hXMLSymbologyNode) End If
	If hXMLTableNode Then Call MIXmlNodeDestroy(hXMLTableNode) End If

	If hXMLSQLTableNode Then Call MIXmlNodeDestroy(hXMLSQLTableNode) End If
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetSymbologyError:
	Note str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Function SetStylePoint(ByVal oObj As Object, ByVal stlSymbol As Symbol) As Object

	Alter Object oObj Info OBJ_INFO_SYMBOL, stlSymbol
	SetStylePoint = oObj

End Function

Function SetStylePolygon(ByVal oObj As Object, ByVal stlPen As Pen, ByVal stlBrush As Brush) As Object

	Alter Object oObj Info OBJ_INFO_PEN, stlPen
	Alter Object oObj Info OBJ_INFO_BRUSH, stlBrush
	SetStylePolygon = oObj

End Function

Sub AboutBox
'***************************************************************
'* Display the 'About' dialog box
'***************************************************************

	Dialog
		Title "About Data Buffer " + sVersion
		Width 230
		Height 115

	Control StaticText
		Title "This program will extract SQL records and/or GIS"
		Position 10,10
	Control StaticText
		Title "layers that intersect with partner boundary feature(s)."
		Position 10,20
	Control StaticText
		Title "The user can select which SQL table or GIS layers"
		Position 10,30
	Control StaticText
		Title "to extract and which partner boundaries to extract for."
		Position 10,40
	Control StaticText
		Title "Created by Andy Foy Consulting."
		Position 10,60
	Control StaticText
		Title "Copyright© 2012-2013 GiGL, 2015 - 2016 TVERC & GiGL."
		Position 10,70
	Control OKButton
		Position 185,95

End Sub

Sub MyPrint(ByVal sMsg As String)
'***************************************************************
'* Bespoke print function
'***************************************************************

	'-------------------------------------------------
	' Open the log file for output
	'-------------------------------------------------
	Open File sLogFileName For Append As #1

	'-------------------------------------------------
	' Write the message passed to the output file

	'-------------------------------------------------
	Print #1, FormatDate$(CurDate()) + " " + FormatTime$(CurTime(),"H:mm:ss") + " : " + sMsg

	'-------------------------------------------------
	' Close the output file
	'-------------------------------------------------
	Close File #1

End Sub

Sub PrintLogFile()
'***************************************************************
'* Open the log file in Notepad
'***************************************************************

	'-------------------------------------------------
	' Open the log file in Notepad
	'-------------------------------------------------
	Dim sCmd As String
	sCmd = "Run Program " +  + Chr$(34) + "NotePad.exe " + sLogFileName + Chr$(34)
	Run Command (sCmd)

End Sub

Sub egsit
'***************************************************************
'* Exit the program
'***************************************************************

	End Program

End Sub
