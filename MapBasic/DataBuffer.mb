'* DataBuffer is a MapBasic tool to buffer and, optionally, consolidate
'* records from one or more MapInfo GIS layers and merge the results
'* into a single output MapInfo GIS layer.
'*
'* Copyright © 2016 - 2018 TVERC, SBIC
'* 
'* This file is part of the MapInfo tool 'DataBuffer'.
'* 
'* DataBuffer is free software: you can redistribute it and/or modify
'* it under the terms of the GNU General Public License as published by
'* the Free Software Foundation, either version 3 of the License, or
'* (at your option) any later version.
'* 
'* DataBuffer is distributed in the hope that it will be useful,
'* but WITHOUT ANY WARRANTY; without even the implied warranty of
'* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'* GNU General Public License for more details.
'* 
'* You should have received a copy of the GNU General Public License
'* along with DataBuffer.  If not, see <http://www.gnu.org/licenses/>.
'*
'***************************************************************
'* DataBuffer v1.0.13
'*
'* Buffers and (optionally) consolidates records from one or more
'* MapInfo GIS layers and merges the results into a new output
'* MapInfo GIS layer.
'*
'*
'* Created:         Andy Foy - February 2016
'* Last revised:    Andy Foy - June 2019
'*
'* *****************  Version 1.0.13  **************
'* Author: Andy Foy		Date: 05/06/2019
'* A. Add option to cluster features or not.
'* B. Add "DefaultCluster" option to XML.
'* C. Add "DefaultClearLogFile" option to XML.
'*
'* *****************  Version 1.0.12  **************
'* Author: Andy Foy		Date: 29/05/2019
'* A. Allow user to select XML profile to use.
'*
'* *****************  Version 1.0.11  **************
'* Author: Andy Foy		Date: 28/05/2019
'* A. Include column type option for List.
'* B. Add split string character to XML for List.
'* C. Allow SortOrder clause to be blank.
'* D. Show node name not table name in interface.
'* E. Apply where clause before clustering features.
'*
'* *****************  Version 1.0.10  **************
'* Author: Andy Foy		Date: 17/12/2018
'* A. Fix links to tool buttons.
'*
'* *****************  Version 1.0.9  ***************
'* Author: Andy Foy		Date: 22/10/2018
'* A. Include new tool buttons for MI Pro 64bit.
'*
'* *****************  Version 1.0.7  ***************
'* Author: Andy Foy		Date: 02/09/2016
'* A. Move output column definitions and spatial
'*	  reference system in XML to OutTable node.
'* B. Set symbology for points, lines and regions in
'*	  output table.
'* C. Include column type options for Min, Max and
'*    count.
'* D. Enable buffer size to be zero.
'*
'* *****************  Version 1.0.6  ***************
'* Author: Andy Foy		Date: 14/07/2016
'* A. Enable separate instances for tool to run under
'*    different names in Tool menu.
'*
'* *****************  Version 1.0.5  ****************
'* Author: Andy Foy		Date: 30/05/2016
'* A. Change version number to 3 parts.
'*
'* *****************  Version 1.04  *****************
'* Author: Andy Foy		Date: 01/04/2016
'* A. Include where clause for input tables.
'*
'* *****************  Version 1.03  *****************
'* Author: Andy Foy		Date: 17/03/2016
'* A. Performance improvements.
'* B. Updated user interface.
'*
'* *****************  Version 1.02  *****************
'* Author: Andy Foy		Date: 09/03/2016
'* A. Ask user if they want to keep the dialog open.
'* B. Open log file using Notepad.exe.
'* 
'* *****************  Version 1.01  *****************
'* Author: Andy Foy		Date: 24/02/2016
'* A. Initial version of tool.
'* 
'***************************************************************
Include "DataBuffer.def"

Sub Main
'***************************************************************
'* Main sub-routine
'***************************************************************

	OnError Goto HandleError

	'-------------------------------------------------
	' Set the version number
	'-------------------------------------------------
	sVersion = "1.0.13"

	'-------------------------------------------------
	' Get the title for the Tool menu
	'-------------------------------------------------
	Call GetToolTitle

	Call CreateToolMenu(sToolTitle)
	
	Exit Sub

HandleError:
	Note "Main: " + Error$()
	Resume Next

End Sub

Sub GetToolTitle
'***************************************************************
'* Retrieve the tool title to use from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode

	OnError Goto GetTitleError

	' Set the default Tool menu title
	sToolTitle = "Data Buffer"

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataBuffer.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Load the default values from the child nodes
					' under the DataBuffer node
					'-------------------------------------------------

					' Title for adding the program to the Tool menu
					Dim sTitle As String
					sTitle = GetSingleNodeValue(hXMLNode, "ToolTitle")
					If sTitle <> "" Then
						sToolTitle = sTitle
					End If

					' Default XML file
					sDefaultXMLFile = GetSingleNodeValue(hXMLNode, "DefaultProfile")
					If sDefaultXMLFile = "" Then
						sDefaultXMLFile = "DefaultProfile"
					End If
					
				End If

			End If

		Else

			Goto GetTitleError

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetTitleError:
	Note "Unable to get tool title from XML config file.  Using default title 'Data Buffer'."
	Exit Sub

End Sub

Sub GetDefaultValues(ByVal sXMLFile As String)
'***************************************************************
'* Retrieve all the default values from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLFilesNodeList As MIXMLNodeList
	Dim hXMLFilesNodeParent As MIXmlNode
	Dim hXMLFilesNode As MIXmlNode
	Dim hXMLColumnsNode As MIXmlNode

	OnError Goto GetVariablesError

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + sXMLFile, bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
				If hXMLNode Then
	
					'-------------------------------------------------
					' Load the default values from the child nodes
					' under the DataBuffer node
					'-------------------------------------------------
					' File path for storing the log file
					Dim sLogFilePath As string
					sLogFilePath = GetSingleNodeValue(hXMLNode, "LogFilePath")
					sLogFileName = sLogFilePath & "\DataBuffer_" & sUserID & ".log"

					' Default file path to store extracts in sub-folders
					sDefaultPath = GetSingleNodeValue(hXMLNode, "DefaultPath")

					' Character to use when splitting an input string
					sSplitChar = GetSingleNodeValue(hXMLNode, "SplitChar")

					' Default option to cluster output features
					sDefaultCluster = GetSingleNodeValue(hXMLNode, "DefaultCluster")

					' Default option to clear log file
					sDefaultClearLogFile= GetSingleNodeValue(hXMLNode, "DefaultClearLogFile")

					'-------------------------------------------------
					' Get a handle on the input tables node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "InTables")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLFilesNodeParent)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the values in an array
					'-------------------------------------------------
					Redim aInTables(99)
					Dim i As Integer
					i = 0
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the table node
						aInTables(i).Node = GetNodeName(hXMLFilesNode)

						' Name of the MapInfo table to be input
						aInTables(i).TableName = GetSingleNodeValue(hXMLFilesNode, "TableName")

						' The columns to read from the input table
						aInTables(i).Columns = GetSingleNodeValue(hXMLFilesNode, "Columns")

						' The where clause to apply to the input table
						aInTables(i).WhereClause = GetSingleNodeValue(hXMLFilesNode, "WhereClause")

						' The column sort order to read the input table
						aInTables(i).SortOrder = GetSingleNodeValue(hXMLFilesNode, "SortOrder")

						' The size of the buffer to apply to the records
						aInTables(i).BufferSize = GetSingleNodeValue(hXMLFilesNode, "BufferSize")

						' The proximity of records to be dissolved together
						aInTables(i).DissolveSize = GetSingleNodeValue(hXMLFilesNode, "DissolveSize")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim aInTables(i)

					'-------------------------------------------------
					' Get a handle on the output table node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "OutTable")

					' Definitions of the columns in the new table
					sOutColumnDefs = GetSingleNodeValue(hXMLFilesNodeParent, "ColumnDefs")

					' Coordinate system to be used for mapping
					sCoordSys = GetSingleNodeValue(hXMLFilesNodeParent, "CoordinateSystem")

					'-------------------------------------------------
					' Get a handle on the columns node for the table
					'-------------------------------------------------
					hXMLColumnsNode = MIXmlSelectSingleNode(hXMLFilesNodeParent, "Columns")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLColumnsNode)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the values in an array
					'-------------------------------------------------
					Redim aOutColumns(99)
					i = 0
					sOutColumns = ""
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the column node
						aOutColumns(i).Node = GetNodeName(hXMLFilesNode)
						If i > 1 Then
							sOutColumns = sOutColumns + ", "
						End If
						sOutColumns = sOutColumns + GetNodeName(hXMLFilesNode)

						' Name of the column to be output to the new buffered layer
						aOutColumns(i).ColumnName = GetSingleNodeValue(hXMLFilesNode, "ColumnName")

						' Type of column to be output to the new buffered layer
						aOutColumns(i).ColumnType = GetSingleNodeValue(hXMLFilesNode, "ColumnType")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim aOutColumns(i)

				End If

			End If

		Else

			Note "Error opening XML config file 'DataBuffer.xml'."

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLColumnsNode Then Call MIXmlNodeDestroy(hXMLColumnsNode) End If
	If hXMLFilesNode Then Call MIXmlNodeDestroy(hXMLFilesNode) End If
	If hXMLFilesNodeList Then Call MIXmlNodeListDestroy(hXMLFilesNodeList) End If
	If hXMLFilesNodeParent Then Call MIXmlNodeDestroy(hXMLFilesNodeParent) End If
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetVariablesError:
	Note "Error: " + str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Sub DataBuffer
'***************************************************************
'* Create the user dialog window
'***************************************************************

	'-------------------------------------------------
	' Trap errors
	'-------------------------------------------------
    OnError Goto ErrorTrap

	'-------------------------------------------------
	' Get the current user ID
	'-------------------------------------------------
	sUserID = GetUserID()
	sUserID = StringReplace(sUserID, " ", "_")
	sUserID = StringReplace(sUserID, ".", "_")

	'-------------------------------------------------
	' Prompt the user for their required config file
	'-------------------------------------------------
	sXMLFile = ""
	Call GetXmlProfile
	If sXMLFile = "" Then
		Exit Sub
	End If
	
	'-------------------------------------------------
	' Retrieve the default values from the config file
	'-------------------------------------------------
	Call GetDefaultValues(sXMLFile)

	'-------------------------------------------------
	' Build a new dialog window
	'-------------------------------------------------
	Dialog
		Title "Data Buffer " + sVersion
		Width 160
		Height 210
		Position 50, 70
		Calling DialogSetup

	'-------------------------------------------------
	' Add a input table listbox
	'-------------------------------------------------
	Control StaticText Title "Input Tables:"
		Position 10, 10
	Control MultiListBox
		ID 1
		Title ""
		Position 10, 20
		Height 120
		Width 140

	'-------------------------------------------------
	' Add a checkbox for clustering output features
	'-------------------------------------------------
	Control CheckBox
		ID 2
		Title "Cluster output features?"
		Position 10,150
		Value bDefaultCluster
		'Into bCluster

	'-------------------------------------------------
	' Add a checkbox for clearing the log file
	'-------------------------------------------------
	Control CheckBox
		ID 6
		Title "Clear log file?"
		Position 10,165
		Value bDefaultClearLogFile
		'Into bClearLog

	'-------------------------------------------------
	' Add Ok and cancel buttons
	'-------------------------------------------------
	Control CancelButton
		Position 65,190
		Width 40
	Control Button
		Title "Ok"
		Position 110,190
		Width 40
		Calling CheckSelection

Done:
	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Resume Done

End Sub

Sub GetXMLProfile()
'***************************************************************
'* Create the user dialog window
'***************************************************************

	'-------------------------------------------------
	' Trap errors
	'-------------------------------------------------
    OnError Goto ErrorTrap

	Dim sFileExclude As String
	sFileExclude = "DataBuffer.xml"
	
	Dim sDir As String
	sDir = ApplicationDirectory$()
	
	Dim bResult As Logical
	Dim sFileNames() as String
	bResult = GetFileList(sDir, "*.xml" , sFileNames(), sFileExclude)
	
	Dim i as integer
	Dim sXMLFiles As String
	sXMLFiles = ""
	If bResult = True And UBound(sFileNames()) > 0 Then
	
		For i = 1 to UBound(sFileNames())
		
			sXMLFiles = sXMLFiles + sFileNames(i) + ";"
	
		Next
		
		sXMLFiles = Left$(sXMLFiles, Len(sXMLFiles) - 1)

	Else

		Note "There are no profile XML files in '" + ApplicationDirectory$() + "'"
		Goto Done

	End If	
	
	If UBound(sFileNames()) = 1 Then
		sXMLFile = sFileNames(1) + ".xml"
		Goto Done
	End If
	
	'-------------------------------------------------
	' Build a new dialog window
	'-------------------------------------------------
	Dialog
		Title "Data Buffer " + sVersion
		Width 190
		Height 80
		Position 50, 70

	'-------------------------------------------------
	' Add a profile table listbox
	'-------------------------------------------------
	Control StaticText Title "Please Choose a Profile:"
		Position 10, 10
	Control PopupMenu
		ID 1
		Title From Variable sXMLFiles
		Value iDefaultXMLFile
		Position 10, 20
		Height 10
		Width 170
		Into iXMLFile

	'-------------------------------------------------
	' Add Ok and cancel buttons
	'-------------------------------------------------
	Control CancelButton
		Position 95,60
		Width 40
	Control OkButton
		Title "Ok"
		Position 140,60
		Width 40
		'Calling CheckSelection

	'-------------------------------------------------
	' Store the dialog variables
	'-------------------------------------------------
	If CommandInfo(CMD_INFO_DLG_OK) Then
		sXMLFile = sFileNames(iXMLFile) + ".xml"
	Else
		sXMLFile = ""
	End If

	'-------------------------------------------------
	' Close the dialog
	'-------------------------------------------------
	'Dialog Remove

Done:
	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Resume Done

End Sub

Sub DialogSetup
'***************************************************************
' Setup the dialog window listboxes
'***************************************************************

	'-------------------------------------------------
	' Clear the Message window and close it
	'-------------------------------------------------
	Print(chr$(12))
	Close Window Message

	'-------------------------------------------------
	' Store the names of any tables not open
	'-------------------------------------------------
	Dim sClosedTables As String, iClosedCount as Integer
	sClosedTables = ""
	iClosedCount = 0
	
	'-------------------------------------------------
	' Loop through all the input tables listed in the
	' config file and add them to the input Table list
	' if they are open in MapInfo
	'-------------------------------------------------
	Dim i, j As Integer
	Dim aOpenTables(99) As String
	Redim aOpenTables(99)
	Redim aInTablesOpen(99)
	j = 0
	For i = 1 to UBound(aInTables)

		'-------------------------------------------------
		' Concatenate all the Map tables into an array
		'-------------------------------------------------
		If TableIsOpen(aInTables(i).TableName) Then
			j = j + 1
			
			aOpenTables(j) = aInTables(i).Node
			
			aInTablesOpen(j).Node = aInTables(i).Node
			aInTablesOpen(j).TableName = aInTables(i).TableName
			aInTablesOpen(j).Columns = aInTables(i).Columns
			aInTablesOpen(j).WhereClause = aInTables(i).WhereClause
			aInTablesOpen(j).SortOrder = aInTables(i).SortOrder
			aInTablesOpen(j).BufferSize = aInTables(i).BufferSize
			aInTablesOpen(j).DissolveSize = aInTables(i).DissolveSize
		Else
			'-------------------------------------------------
			' Store the name of the closed table
			'-------------------------------------------------
			sClosedTables = sClosedTables + Chr$(13) + aInTables(i).TableName
			iClosedCount = iClosedCount + 1
		End If

	Next

	Redim aInTablesOpen(j)
	Redim aOpenTables(j)

	'-------------------------------------------------
	' Update the input table list to show the list
	' of open tables
	'-------------------------------------------------
	Alter Control 1 Title FROM Variable aOpenTables

	'-------------------------------------------------
	' Warn the user of the closed tables
	'-------------------------------------------------
	If iClosedCount > 0 Then
		If iClosedCount = 1 Then
			Note "Warning: the following table is not open ..." + Chr$(13) + sClosedTables
		Else
			Note "Warning: " + iClosedCount + " tables are not open, including ..." + Chr$(13)+ sClosedTables
		End If
	End If

SetDefaults:

	'-------------------------------------------------
	' Set the default value for clustering the output
	' features
	'-------------------------------------------------
	If UCase$(sDefaultCluster) = "YES" OR UCase$(sDefaultCluster) = "Y" Then
		Alter Control 2 Value TRUE
	Else
		Alter Control 2 Value FALSE
	End If

	'-------------------------------------------------
	' Set the default value for clearing the log file
	'-------------------------------------------------
	If UCase$(sDefaultClearLogFile) = "YES" OR UCase$(sDefaultClearLogFile) = "Y" Then
		Alter Control 6 Value TRUE
	Else
		Alter Control 6 Value FALSE
	End If

End Sub

Sub CheckSelection
'***************************************************************
'* Check the user's selections and process according
'***************************************************************

	'-------------------------------------------------
	' Store the dialog variables
	'-------------------------------------------------
	bCluster = ReadControlValue(2)
	bClearLog = ReadControlValue(6)

	'-------------------------------------------------
	' Check if the user has selected at least one input
	' table
	'-------------------------------------------------
	iInTable = ReadControlValue(1)
	if iInTable = 0 then
		Note "No input tables have been selected!"
		Exit Sub
	End If

	'-------------------------------------------------
	' Reset the global variables
	'-------------------------------------------------
	iInTableTot = 0
	iInTableCnt = 0

	'-------------------------------------------------
	' Count the number of input tables to process
	'-------------------------------------------------
	Do While iInTable > 0
	
		'-------------------------------------------------
		' Increment the counters
		'-------------------------------------------------
		iInTableTot = iInTableTot + 1

		aInTablesSelected(iInTableTot).Node = aInTablesOpen(iInTable).Node
		aInTablesSelected(iInTableTot).TableName = aInTablesOpen(iInTable).TableName
		aInTablesSelected(iInTableTot).Columns = aInTablesOpen(iInTable).Columns
		aInTablesSelected(iInTableTot).WhereClause = aInTablesOpen(iInTable).WhereClause
		aInTablesSelected(iInTableTot).SortOrder = aInTablesOpen(iInTable).SortOrder
		aInTablesSelected(iInTableTot).BufferSize = aInTablesOpen(iInTable).BufferSize
		aInTablesSelected(iInTableTot).DissolveSize = aInTablesOpen(iInTable).DissolveSize

		'-------------------------------------------------
		' Read the next input table selected in the list
		'-------------------------------------------------
		iInTable = ReadControlValue(1)

	Loop

	'-------------------------------------------------
	' Prompt the user for the output file destination
	'-------------------------------------------------
	Dim sOutputFile As String
	sOutputFile = FileSaveAsDlg(sDefaultPath, "", "TAB", "Select where to save the output file")

	if sOutputFile = "" then
		Call MyPrint("No output file selected - process cancelled.")
		Note "No output file selected - process cancelled."
		Exit Sub
	End If

	'-------------------------------------------------
	' Get the path and name of the selected output file
	'-------------------------------------------------
	sOutputPath = PathToDirectory$(sOutputFile)
	sOutputName = PathToFileName$(sOutputFile)

	'-------------------------------------------------
	' Check the selected directory already exists
	'-------------------------------------------------
	Dim iSuccess, iSecurity As Integer
	iSecurity = 0
	iSuccess = SetCurrentDirectory(sOutputPath)
	if iSuccess = 0 Then
		Call MyPrint("Output folder does not exist - process cancelled.")
		Note "Output folder does not exist - process cancelled."
		Exit Sub
	End If

	'-------------------------------------------------
	' Check the selected file name has the correct
	' extension
	'-------------------------------------------------
	if UCase$(Right$(sOutputName, 3)) <> UCase$("TAB") Then
		Call MyPrint("Output file has incorrect extension - process cancelled.")
		Note "Output file has incorrect extension - process cancelled."
		Exit Sub
	End If

	'-------------------------------------------------
	' Clear the log file (if it exists)
	'-------------------------------------------------
	If bClearLog = True Then
		If FileExists(sLogFileName) Then
			Kill sLogFileName
		End If

	End If

	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("Process started!")
	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("")

	'-------------------------------------------------
	' Remove the file extension from the output file name
	'-------------------------------------------------
	sOutputName = Left$(sOutputName, Len(sOutputName) - 4)

	Call MyPrint("Output File = '" + sOutputFile + "'.")

	'-------------------------------------------------
	' Call the subroutine to create the new
	' output buffer table.
	'-------------------------------------------------
	Call CreateBufferTable(sOutputPath, sOutputName)
	Dim lResponse As Logical
	If sOutputName = "" Then
		Call MyPrint("Error creating output buffer table.")
		Call MyPrint("")
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process stopped!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Process stopped!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
		Goto Response
	End If

	'-------------------------------------------------
	' Process the selected tables one by one
	'-------------------------------------------------
	iInTableCnt = 1
	ProgressBar "Processing " + iInTableTot + " input tables ..."
		Calling ProcessTables
		Range iInTableTot

	'-------------------------------------------------
	' If the process was interrupted by the user
	'-------------------------------------------------
	If Not CommandInfo(CMD_INFO_STATUS) Then
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process interrupted by user!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Processing interrupted!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
		Goto Response
	End If

	Set ProgressBars Off

	'-------------------------------------------------
	' Drop the temporary column
	'-------------------------------------------------
	Alter Table sOutputName (Drop Temp)

	'-------------------------------------------------
	' Pack the output table
	'-------------------------------------------------
	Pack Table sOutputName Graphic Data

	Set ProgressBars On

	'-------------------------------------------------
	' Count the number of buffered records
	'-------------------------------------------------
	Dim iRows As Integer
	iRows = TableInfo(sOutputName, TAB_INFO_NROWS)

	Call MyPrint("Created a total of " + FormatNumber$(iRows) + " buffered features.")
	Call MyPrint("")
	
	'-------------------------------------------------
	' Turn on FastEdit to speed up the updates
	'-------------------------------------------------
	Set Table sOutputName FastEdit On

	'-------------------------------------------------
	' Set the symbology for the table before closing
	'-------------------------------------------------
	Call SetSymbology(sOutputName)

	Dim sCmd As String
	sCmd = "Commit Table " + sOutputName
	Run Command (sCmd)

	'-------------------------------------------------
	' Turn FastEdit off once updates are done
	'-------------------------------------------------
	Set Table sOutputName FastEdit Off

	'-------------------------------------------------
	' Add the output table to the top most map window
	' (if there is one), otherwise create a new map
	' window using the table
	'-------------------------------------------------
	If NumWindows() > 0 Then
		Add Map Layer sOutputName
	Else
		Map From sOutputName
	End If

	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("Process completed!")
	Call MyPrint("----------------------------------------------------------------------")

	'-------------------------------------------------
	' Ask the user if they want to close the form
	'-------------------------------------------------
	lResponse = Ask("Processing complete!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")

Response:
	If lResponse = True Then
		'-------------------------------------------------
		' Close the dialog
		'-------------------------------------------------
		Dialog Remove

	End If

	'-------------------------------------------------
	' Display the log file in the message window
	'-------------------------------------------------
	Call PrintLogFile

End Sub

Sub CreateBufferTable (sOutputPath As String, sOutputName As String)
'*************************************************
'* Routine to create a new output buffer table.
'*************************************************

	'-------------------------------------------------
	' Replace any spaces in the output table name with
	' underscores and remove hyphens
	'-------------------------------------------------
	sOutputName = StringReplace(sOutputName, " ", "_")
	sOutputName = StringReplace(sOutputName, "-", "")

	'-------------------------------------------------
	' Check if an existing output table is
	' already/still open and close it if it is
	'-------------------------------------------------
	If TableIsOpen(sOutputName) Then
		Call MyPrint("Closing old output buffer table ...")
		Close Table sOutputName
	End If

	OnError Goto CreateError

	Call MyPrint("Creating output buffer table ...")

	'-------------------------------------------------
	' Create new output table"
	'-------------------------------------------------
	Dim sCmd As String
	sCmd = "Create Table " + Chr$(34) + sOutputName + Chr$(34) + " (" + sOutColumnDefs + ", Temp Integer) file " + Chr$(34) + sOutputPath + sOutputName + ".tab" + Chr$(34)
	+ " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
	Run Command (sCmd)

	'-------------------------------------------------
	' Add an index to the temp field to speed
	' up queries
	'-------------------------------------------------
	sCmd = "Create Index On " + sOutputName + "(temp)"
	Run Command (sCmd)

	'-------------------------------------------------
	' Make output table mappable
	'-------------------------------------------------
	sCmd = "Create Map For " + sOutputName + " CoordSys " + sCoordSys
	Run Command (sCmd)

'	'-------------------------------------------------
'	' Find the layer number of the search table by
'	' looking through all the windows until it is
'	' found
'	'-------------------------------------------------
'	Dim iNumWindows As Integer
'	iNumWindows = UBound(aWindowId)
'	Dim iWindowNum As Integer
'	For iWindowNum = 1 to iNumWindows
'		Dim iNumTables As Integer
'		Dim iNumSearchTable as Integer
'		iNumTables = MapperInfo(aWindowId(iWindowNum), MAPPER_INFO_LAYERS)
'		For iNumSearchTable = 1 to iNumTables
'			If LayerInfo(aWindowId(iWindowNum),iNumSearchTable, LAYER_INFO_NAME) = sSearchTable Then
'				Goto EditLayer
'			End If
'		Next
'	Next
'
'EditLayer:
'	'-------------------------------------------------
'	' Make the layer editable
'	'-------------------------------------------------
'	If LayerInfo(aWindowId(iWindowNum),iNumSearchTable,LAYER_INFO_EDITABLE) = False Then
'		Set Map Window aWindowId(iWindowNum) Layer iNumSearchTable Editable On
'	End If

	Call MyPrint("Created output buffer table.")
	Call MyPrint("")

	Exit Sub

CreateError:
	sOutputName = ""

End Sub

Sub ProcessTables()
'***************************************************************
'* Process the input table
'***************************************************************

	Dim sNodeName, sTableName, sColumns, sWhereClause, sSortOrder As String
	Dim iBufferSize, iDissolveSize As Integer
	sNodeName = aInTablesSelected(iInTableCnt).Node
	sTableName = aInTablesSelected(iInTableCnt).TableName
	sColumns = aInTablesSelected(iInTableCnt).Columns
	sWhereClause = aInTablesSelected(iInTableCnt).WhereClause
	sSortOrder = aInTablesSelected(iInTableCnt).SortOrder
	iBufferSize = aInTablesSelected(iInTableCnt).BufferSize
	iDissolveSize = aInTablesSelected(iInTableCnt).DissolveSize

	Call MyPrint("Processing table " + sNodeName + " (" + iInTableCnt + " of " + iInTableTot + ") ...")

	'-------------------------------------------------
	' Call the subroutine to select the records from
	' the selected table for the selected partner
	'-------------------------------------------------
	Call BufferRecords(sTableName, sColumns, sWhereClause, sSortOrder, iBufferSize, iDissolveSize)

	Call MyPrint("Completed process " + iInTableCnt + " of " + iInTableTot + ".")
	Call MyPrint("")

	'-------------------------------------------------
	' Increment the progress bar to show progress
	'-------------------------------------------------
	ProgressBar = iInTableCnt

	'-------------------------------------------------
	' Go to the next selection in the list
	'-------------------------------------------------
	iInTableCnt = iInTableCnt + 1
	If iInTableCnt > iInTableTot Then
		'-------------------------------------------------
		' Halt processing
		'-------------------------------------------------
		ProgressBar = -1
	End If

End Sub

Sub BufferRecords
	(sTableName As String,
	sColumns As String,
	sWhereClause As String,
	sSortOrder As String,
	iBufferSize As Integer,
	iDissolveSize As Integer)
'*************************************************
'* Routine to select the records from the
'* MapInfo table name passed in the call, buffer
'* and/or dissolve them and copy them to the
'* output table.
'*************************************************

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Setup the temporary table names
	'-------------------------------------------------
	Dim sTempInput, sTempTable, sTempOutput As String
	sTempInput = "TempInput"
	sTempTable = "TempTable"
	sTempOutput = "TempOutput"

	Dim sTempSelect As String
	sTempSelect = "TempSelect"

	Dim sTempCluster As String
	sTempCluster = "TempCluster"

	'-------------------------------------------------
	' Check if the temporary tables are already/still
	' open and close them if it is
	'-------------------------------------------------
	If TableIsOpen(sTempInput) Then
		Close Table sTempInput
	End If

	If TableIsOpen(sTempTable) Then
		Close Table sTempTable
	End If

	If TableIsOpen(sTempOutput) Then
		Close Table sTempOutput
	End If

	If TableIsOpen(sTempSelect) Then
		Close Table sTempSelect
	End If

	If TableIsOpen(sTempCluster) Then
		Close Table sTempCluster
	End If

	'-------------------------------------------------
	' Copy the required rows to a temporary table
	'-------------------------------------------------
	Call MyPrint("Creating temporary table from " + sTableName + " ...")

	Dim sClause As String
	sClause = sWhereClause
	If sWhereClause <> "" Then
		sClause = " Where " + sWhereClause
	End If

	Dim sOrder As String
	sOrder = sSortOrder
	If sSortOrder <> "" Then
		sOrder = " Order By " + sSortOrder
	End If

	Dim sCmd As String
	sCmd = "Select * From " + sTableName + sClause + sOrder + " Into " + sTempInput + " NoSelect"
	Run Command (sCmd)

	sCmd = "Commit Table " + sTempInput + " As " + Chr$(34) + sOutputPath + "\" + sTempInput + ".tab" + Chr$(34) + " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
	Run Command (sCmd)

	Close Table sTempInput

	sCmd = "Open Table " + Chr$(34) + sOutputPath + "\" + sTempInput + ".tab" + Chr$(34) + " As " + sTempInput
	Run Command (sCmd)

	'-------------------------------------------------
	' Count the number of rows selected
	'-------------------------------------------------
	Dim iRows As Integer
	iRows = TableInfo(sTempInput, TAB_INFO_NROWS)

	If iRows = 0 Then
		Call MyPrint("No rows selected.")
		Goto CleanUp
	End If

	'-------------------------------------------------
	' Build a string of all the column names
	'-------------------------------------------------
	Dim sColData As String
	sColData = ""

	Dim sColName As String
	Dim iColNum As Integer
	For iColNum = 1 To TableInfo(sTempInput, TAB_INFO_NCOLS)
	   sColName = ColumnInfo(sTempInput, "COL" & iColNum, COL_INFO_NAME)
	   sColData = sColData + sColName + "=" + sColName + ","
	Next
	
	sColData = Left$(sColData, Len(sColData) - 1)
	
	'-------------------------------------------------
	' Turn on FastEdit to speed up the updates
	'-------------------------------------------------
	Set Table sTempInput FastEdit On
	Set Table sTempInput Undo Off

	'-------------------------------------------------
	' Select all the objects
	'-------------------------------------------------
	sCmd = "Select * From " + sTempInput + " Into Selection"
	Run Command (sCmd)

	'-------------------------------------------------
	' Disaggregate all the objects
	'-------------------------------------------------
	sCmd = "Objects Disaggregate Into Table " + sTempInput + " Data " + sColData
	Run Command (sCmd)

	'-------------------------------------------------
	' Save the dissagregated objects
	'-------------------------------------------------
	sCmd = "Commit Table " + sTempInput
	Run Command (sCmd)
	
	'-------------------------------------------------
	' If a temporary unique column doesn't already
	' exist
	'-------------------------------------------------
	If Not ColumnExists(sTempInput, "RowInd") Then

		Call MyPrint("Adding temporary key to " + sTempInput + " ...")

		'-------------------------------------------------
		' Add a temporary unique column
		'-------------------------------------------------
		Alter Table sTempInput (Add RowInd Integer)

		'-------------------------------------------------
		' Add an index to the unique column to speed
		' up queries
		'-------------------------------------------------
		sCmd = "Create Index On " + sTempInput + "(RowInd)"
		Run Command (sCmd)

		'-------------------------------------------------
		' Turn on FastEdit to speed up the updates
		'-------------------------------------------------
		Set Table sTempInput FastEdit On
		Set Table sTempInput Undo Off

		'-------------------------------------------------
		' Update the unique column in the table
		'-------------------------------------------------
		sCmd = "Update " + sTempInput + " Set RowInd = RowID"
		Run Command (sCmd)

		'-------------------------------------------------
		' Save the updates
		'-------------------------------------------------
		sCmd = "Commit Table " + sTempInput
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Turn off FastEdit after updates
		'-------------------------------------------------
		Set Table sTempInput FastEdit Off
		Set Table sTempInput Undo On

	End If

	Call MyPrint("Buffering features to " + iBufferSize + " metres ...")

	'-------------------------------------------------
	' Loop through every column in the output table
	' to check if there is a key column
	'-------------------------------------------------
	Dim bKeyFound As Logical
	bKeyFound = False
	Dim iColumn As Integer
	For iColumn = 1 to UBound(aOutColumns)
		If UCase$(aOutColumns(iColumn).ColumnType) = "KEY" Or
		   UCase$(aOutColumns(iColumn).ColumnType) = "CLUSTER" Then
			bKeyFound = True
		End If
	Next

	'-------------------------------------------------
	' If there is no key column then cluster the
	' adjacent records
	'-------------------------------------------------
	Dim iClusterSize As Float
	iClusterSize = iDissolveSize - 1

	If bCluster = True And bKeyFound = False Then
		Call MyPrint("No key field found. Adjacent features will be clustered.")
		iClusterSize = 0
	End If

	'-------------------------------------------------
	' If the records need to be clustered (dissolved)
	'-------------------------------------------------
	If bCluster Then

		Call MyPrint("Clustering features within " + iDissolveSize + " metres ...")

		'-------------------------------------------------
		' Create a new cluster table for the input records
		' if they are to be dissolved
		'-------------------------------------------------
		sCmd = "Create Table " + Chr$(34) + sTempCluster + Chr$(34) + " (ClusterID Integer) file " + Chr$(34) + sOutputPath + "\" + sTempCluster + ".tab" + Chr$(34) + " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Make the cluster table mappable
		'-------------------------------------------------
		sCmd = "Create Map For " + sTempCluster + " CoordSys " + sCoordSys
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Turn on FastEdit to speed up the updates
		'-------------------------------------------------
		Set Table sTempCluster FastEdit On
		Set Table sTempCluster Undo Off

		'-------------------------------------------------
		' Create a single clustered object
		'-------------------------------------------------
		sCmd = "Create Object As Buffer From " + sTempInput + " Width " + iClusterSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sTempCluster
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Disaggregate the clustered object
		'-------------------------------------------------
		sCmd = "Objects Disaggregate Into Table " + sTempCluster
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Update the ClusterId in the table
		'-------------------------------------------------
		sCmd = "Update " + sTempCluster + " Set ClusterID = RowID - 1"
		Run Command (sCmd)
	
		'-------------------------------------------------
		' Save the clustered objects
		'-------------------------------------------------
		sCmd = "Commit Table " + sTempCluster
		Run Command (sCmd)
		
		'-------------------------------------------------
		' Turn off FastEdit after updates
		'-------------------------------------------------
		Set Table sTempCluster FastEdit Off
		Set Table sTempCluster Undo On

		'-------------------------------------------------
		' Close the latest query table
		'-------------------------------------------------
		Dim t As SmallInt
		For t = NumTables() to 1 Step -1
			If TableInfo(t, TAB_INFO_TEMP) Then
				Close Table TableInfo(t, TAB_INFO_NAME)
				Exit For
			End If
		Next

	End If

	'-------------------------------------------------
	' If the records need to be clustered (dissolved)
	' then include the cluster ID from the overlapping
	' cluster
	'-------------------------------------------------
	If bCluster Then
		If sWhereClause <> "" Then
			sWhereClause = " And " + sWhereClause
		End If
		sCmd = "Select " + sColumns + ", " + sTempInput + ".Obj, ClusterID, RowInd From " + sTempInput + ", " + sTempCluster + " Where " + sTempInput + ".Obj Within " + sTempCluster + ".Obj" + sWhereClause + " Order By ClusterID, RowInd Into " + sTempTable + " NoSelect"
	Else
		If sWhereClause <> "" Then
			sWhereClause = " Where " + sWhereClause
		End If
		sCmd = "Select " + sColumns + ", Obj, 0" + Chr$(34) + "ClusterID" + Chr$(34) + ", RowInd From " + sTempInput + sWhereClause + " Order By RowInd Into " + sTempTable + " NoSelect"
	End If
	Run Command (sCmd)

	'-------------------------------------------------
	' Count the number of rows selected
	'-------------------------------------------------
	iRows = TableInfo(sTempTable, TAB_INFO_NROWS)

	Call MyPrint("Buffering " + FormatNumber$(iRows) + " features ...")	
	
	'-------------------------------------------------
	' Reset the output counter
	'-------------------------------------------------
	Dim iOutCount As Integer
	iOutCount = 0

	'-------------------------------------------------
	' Reset the column values
	'-------------------------------------------------
	For iColumn = 1 to UBound(aOutColumns)
		aColumnValues(iColumn).ValKey = ""
		aColumnValues(iColumn).ValMin = ""
		aColumnValues(iColumn).ValMax = ""
		aColumnValues(iColumn).ValFirst = ""
		aColumnValues(iColumn).ValCommon = ""
		aColumnValues(iColumn).ValList = ""
	Next

	'-------------------------------------------------
	' Turn on FastEdit to speed up the updates
	'-------------------------------------------------
	Set Table sOutputName FastEdit On
	Set Table sOutputName Undo Off

	'-------------------------------------------------
	' If any rows were selected then set the object
	'-------------------------------------------------
	If iRows > 0 Then

		'-------------------------------------------------
		' Set the coordinate system to that of the table
		'-------------------------------------------------
		Set Coordsys table TempTable

		'-------------------------------------------------
		' Fetch the first of the selected rows
		'-------------------------------------------------
		Fetch First from TempTable

		Dim aColumn As Alias, sColumnVal As String
		Dim bSame As Logical
		bSame = False
		
		Dim iLastClusterId As Integer
		iLastClusterId = 0
	
		'-------------------------------------------------
		' Loop through all the selected rows buffer the
		' spatial objects
		'-------------------------------------------------
		Dim iRow as Integer
		iRow = 1
		Do while iRow <= iRows

			'-------------------------------------------------
			' If this is not the same cluster
			'-------------------------------------------------
			If iLastClusterId <> TempTable.ClusterID Then

				bSame = False

			Else

				'-------------------------------------------------
				' Loop through every column in the output table
				' to check if the key columns have changed
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Check if the key columns have changed from the
					' last record
					'-------------------------------------------------
					Do Case UCase$(aOutColumns(iColumn).ColumnType)
						Case "KEY"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempTable.Col" + iColumn
			
							'-------------------------------------------------
							' Get the value of the column (and remove double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
					
							'-------------------------------------------------
							' Check if the value has changed
							'-------------------------------------------------
							If aColumnValues(iColumn).ValKey <> sColumnVal Then
								bSame = False
							End If
						Case "CLUSTER"
							'-------------------------------------------------
							' Only check values if the records are not being
							' clustered.
							'-------------------------------------------------
							If bCluster = False Then
								'-------------------------------------------------
								' Set an alias for the column
								'-------------------------------------------------
								aColumn = "TempTable.Col" + iColumn
				
								'-------------------------------------------------
								' Get the value of the column (and remove any
								' double quotes)
								'-------------------------------------------------
								sColumnVal = aColumn
								If Instr(1, sColumnVal, Chr$(34)) > 0 Then
									sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
								End If
						
								'-------------------------------------------------
								' Check if the value has changed
								'-------------------------------------------------
								If aColumnValues(iColumn).ValKey <> sColumnVal Then
									bSame = False
								End If
							End If
						Case Else
					End Case
				Next
			
			End If

			'-------------------------------------------------
			' If the key columns have not changed and this is
			' the same cluster
			'-------------------------------------------------
			If bSame = True Then

				'-------------------------------------------------
				' Loop through every column in the output table
				' to update the values
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Check if the range columns have changed
					'-------------------------------------------------
					Do Case UCase$(aOutColumns(iColumn).ColumnType)
						Case "RANGE"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempTable.Col" + iColumn
							
							'-------------------------------------------------
							' Get the value of the column (and remove any
							' double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
				
							' Check if the min or max values have changed
							If sColumnVal < aColumnValues(iColumn).ValMin Then
								aColumnValues(iColumn).ValMin = sColumnVal
							End If
							If sColumnVal > aColumnValues(iColumn).ValMax Then
								aColumnValues(iColumn).ValMax = sColumnVal
							End If
						Case "MIN"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempTable.Col" + iColumn
							
							'-------------------------------------------------
							' Get the value of the column (and remove any
							' double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
				
							' Check if the min value has changed
							If sColumnVal < aColumnValues(iColumn).ValMin Then
								aColumnValues(iColumn).ValMin = sColumnVal
							End If
						Case "MAX"
							'-------------------------------------------------
							' Set an alias for the column
							'-------------------------------------------------
							aColumn = "TempTable.Col" + iColumn
							
							'-------------------------------------------------
							' Get the value of the column (and remove any
							' double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
				
							' Check if the max value has changed
							If sColumnVal > aColumnValues(iColumn).ValMax Then
								aColumnValues(iColumn).ValMax = sColumnVal
							End If
						Case "LIST"
							'-------------------------------------------------
							' Set an alias for the column

							'-------------------------------------------------
							aColumn = "TempTable.Col" + iColumn
							
							'-------------------------------------------------
							' Get the value of the column (and remove any
							' double quotes)
							'-------------------------------------------------
							sColumnVal = aColumn
							If Instr(1, sColumnVal, Chr$(34)) > 0 Then
								sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
							End If
				
							' If the column value is not already in the list then add it
							If Instr(1, aColumnValues(iColumn).ValList, Chr$(36) + sColumnVal + Chr$(36)) = 0 Then
								aColumnValues(iColumn).ValList = aColumnValues(iColumn).ValList + sSplitChar + " " + Chr$(36) + sColumnVal + Chr$(36)
							End If
						Case Else
					End Case
					
				Next		

			'-------------------------------------------------
			' If the key columns have changed
			'-------------------------------------------------
			Else

				If iRow > 1 Then

					'-------------------------------------------------
					' Select all the 'Temp' objects
					'-------------------------------------------------
					sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
					Run Command (sCmd)

					'-------------------------------------------------
					' Count the number of objects
					'-------------------------------------------------
					Dim iRecs As Integer
					iRecs = TableInfo(sTempOutput, TAB_INFO_NROWS)

					'-------------------------------------------------
					' Loop through every column in the output table
					' to set the values
					'-------------------------------------------------
					Dim sData As String
					sData = " Data "
					For iColumn = 1 to UBound(aOutColumns)
	
						Do Case UCase$(aOutColumns(iColumn).ColumnType)
							Case "KEY"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
							Case "CLUSTER"
								If bCluster = False Then
									sColumnVal = aColumnValues(iColumn).ValKey
									sColumnVal = StringReplace(sColumnVal, Chr$(34), "")

									sData = sData + " Col" + iColumn + " = " + Chr$(34) + sColumnVal + Chr$(34)
								Else
									sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
									Run Command (sCmd)
									Fetch First from TempCommon
									
									Dim sCommonVal As String
									sCommonVal = TempCommon.Col1
									sCommonVal = StringReplace(sCommonVal, Chr$(34), "")
	
									'If TableIsOpen("TempCommon") Then
									'	Close Table TempCommon
									'End If
	
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
								End If
							Case "FIRST"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValFirst + Chr$(34)
							Case "COMMON"
								sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
								Run Command (sCmd)
								Fetch First from TempCommon
								
								sCommonVal = TempCommon.Col1
								sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

								'If TableIsOpen("TempCommon") Then
								'	Close Table TempCommon
								'End If

								sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
							Case "RANGE"
								If aColumnValues(iColumn).ValMin = aColumnValues(iColumn).ValMax Then
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
								Else
									sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + " - " + aColumnValues(iColumn).ValMax + Chr$(34)
								End If
							Case "MIN"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
							Case "MAX"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMax + Chr$(34)
							Case "COUNT"
								sData = sData + " Col" + iColumn + " = " + iRecs
							Case "LIST"
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + StringReplace(aColumnValues(iColumn).ValList, Chr$(36), "") + Chr$(34)
							Case Else
								sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
						End Case
						
						sData = sData + ","
						
					Next
						
					sData = sData + " Temp = 0"
						
					'-------------------------------------------------
					' Create a buffered object from the 'Temp' objects
					'-------------------------------------------------
					If iBufferSize > 0 then
						sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
					Else
						sCmd = "Create Object As Union From " + sTempOutput + " Into Table " + sOutputName + sData
					End If
					Run Command (sCmd)

					'-------------------------------------------------
					' Increment the output counter
					'-------------------------------------------------
					iOutCount = iOutCount + 1

					'-------------------------------------------------
					' Delete all the original 'Temp' objects
					'-------------------------------------------------
					sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
					Run Command (sCmd)

					sCmd = "Delete From " + sTempOutput
					Run Command (sCmd)

				End If

				'-------------------------------------------------
				' Loop through every column in the output table
				' to set the values
				'-------------------------------------------------
				For iColumn = 1 to UBound(aOutColumns)
					
					'-------------------------------------------------
					' Set an alias for the column
					'-------------------------------------------------
					aColumn = "TempTable.Col" + iColumn

					'-------------------------------------------------
					' Get the value of the column (and remove any
					' double quotes)
					'-------------------------------------------------
					sColumnVal = aColumn
					If Instr(1, sColumnVal, Chr$(34)) > 0 Then
						sColumnVal = StringReplace(sColumnVal, Chr$(34), "")
					End If				
	
					'-------------------------------------------------
					' Set the column values
					'-------------------------------------------------
					aColumnValues(iColumn).ValKey = sColumnVal
					aColumnValues(iColumn).ValMin = sColumnVal
					aColumnValues(iColumn).ValMax = sColumnVal
					aColumnValues(iColumn).ValFirst = sColumnVal
					aColumnValues(iColumn).ValCommon = sColumnVal
					aColumnValues(iColumn).ValList = Chr$(36) + sColumnVal + Chr$(36)
					
					'-------------------------------------------------
					' Store the cluster ID
					'-------------------------------------------------
					iLastClusterId = TempTable.ClusterID
					
				Next
				
				bSame = True
				
			End If

			'-------------------------------------------------
			' Copy the record into the output table as a
			' 'Temp' object
			'-------------------------------------------------
			sCmd = "Select " + sColumns + ", 1 " + Chr$(34) + "Temp" + Chr$(34) + ", Obj From " + sTempInput + " Where RowInd = " + TempTable.RowInd + " Into TempInsert NoSelect"
			Run Command (sCmd)

			sCmd = "Insert Into " + sOutputName + " (" + sOutColumns + ", Temp, Obj) Select * From TempInsert"
			Run Command (sCmd)

			'If TableIsOpen("TempInsert") Then
			'	Close Table TempInsert
			'End If

			'-------------------------------------------------
			' Fetch the next of the selected rows
			'-------------------------------------------------
			Fetch Next From sTempTable
			iRow = iRow + 1

		Loop

		'-------------------------------------------------
		' Process the final row ...
		'-------------------------------------------------

		'-------------------------------------------------
		' Select all the 'Temp' objects
		'-------------------------------------------------
		sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
		Run Command (sCmd)

		'-------------------------------------------------
		' Count the number of objects
		'-------------------------------------------------
		iRecs = TableInfo(sTempOutput, TAB_INFO_NROWS)

		'-------------------------------------------------
		' Loop through every column in the output table
		' to set the values
		'-------------------------------------------------
		sData = " Data "
		For iColumn = 1 to UBound(aOutColumns)

			Do Case aOutColumns(iColumn).ColumnType
				Case "Key"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
				Case "Cluster"
					If bCluster = False Then
						sColumnVal = aColumnValues(iColumn).ValKey
						sColumnVal = StringReplace(sColumnVal, Chr$(34), "")

						sData = sData + " Col" + iColumn + " = " + Chr$(34) + sColumnVal + Chr$(34)
					Else
						sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
						Run Command (sCmd)
						Fetch First from TempCommon
						
						sCommonVal = TempCommon.Col1
						sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

						'If TableIsOpen("TempCommon") Then
						'	Close Table TempCommon
						'End If

						sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
					End If
				Case "First"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValFirst + Chr$(34)
				Case "Common"
					sCmd = "Select Col" + iColumn + ", Count(*) " + Chr$(34) + "Recs" + Chr$(34) + " From " + sOutputName + " Where Temp = 1 Group By Col" + iColumn + " Order By Recs Desc Into TempCommon NoSelect"
					Run Command (sCmd)
					Fetch First from TempCommon
					
					sCommonVal = TempCommon.Col1
					sCommonVal = StringReplace(sCommonVal, Chr$(34), "")

					'If TableIsOpen("TempCommon") Then
					'	Close Table TempCommon
					'End If

					sData = sData + " Col" + iColumn + " = " + Chr$(34) + sCommonVal + Chr$(34)
				Case "Range"
					If aColumnValues(iColumn).ValMin = aColumnValues(iColumn).ValMax Then
						sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
					Else
						sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + " - " + aColumnValues(iColumn).ValMax + Chr$(34)
					End If
				Case "Min"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMin + Chr$(34)
				Case "Max"
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValMax + Chr$(34)
				Case "Count"
					sData = sData + " Col" + iColumn + " = " + iRecs
				Case Else
					sData = sData + " Col" + iColumn + " = " + Chr$(34) + aColumnValues(iColumn).ValKey + Chr$(34)
			End Case
			
			sData = sData + ","
			
		Next
			
		sData = sData + " Temp = 0"
					
		'-------------------------------------------------
		' Create a buffered object from the 'Temp' objects
		'-------------------------------------------------
		If iBufferSize > 0 then
			sCmd = "Create Object As Buffer From " + sTempOutput + " Width " + iBufferSize + " Units " + Chr$(34) + "m" + Chr$(34) + " Type Spherical Resolution 100 Into Table " + sOutputName + sData
		Else
			sCmd = "Create Object As Union From " + sTempOutput + " Into Table " + sOutputName + sData
		End If
		Run Command (sCmd)
		
		'-------------------------------------------------
		' Increment the output counter
		'-------------------------------------------------
		iOutCount = iOutCount + 1

		'-------------------------------------------------
		' Delete all the original 'Temp' objects
		'-------------------------------------------------
		sCmd = "Select * From " + sOutputName + " Where Temp = 1 Into " + sTempOutput + " NoSelect"
		Run Command (sCmd)

		sCmd = "Delete From " + sTempOutput
		Run Command (sCmd)

		'-------------------------------------------------
		' Save the updates
		'-------------------------------------------------
		Set ProgressBars Off

		sCmd = "Commit Table " + sOutputName
		Run Command (sCmd)

		'-------------------------------------------------
		' Turn off FastEdit after updates
		'-------------------------------------------------
		Set Table sOutputName FastEdit Off
		Set Table sOutputName Undo On

		Set ProgressBars On

		Call MyPrint("Created " + FormatNumber$(iOutCount) + " buffered features.")

	End If

CleanUp:

	OnError Goto 0
	
	'-------------------------------------------------
	' Close the temporary tables
	'-------------------------------------------------
	If TableIsOpen(sTempTable) Then
		Close Table sTempTable
	End If

	If TableIsOpen(sTempOutput) Then
		Close Table sTempOutput
	End If

	If TableIsOpen(sTempSelect) Then
		Close Table sTempSelect
	End If

	If TableIsOpen("TempInsert") Then
		Close Table TempInsert
	End If

	If TableIsOpen("TempCommon") Then
		Close Table TempCommon
	End If

	'-------------------------------------------------
	' Drop the temporary input table
	'-------------------------------------------------
	If TableIsOpen(sTempInput) Then
		Drop Table sTempInput
	End If

	'-------------------------------------------------
	' Drop the temporary cluster table
	'-------------------------------------------------
	If TableIsOpen(sTempCluster) Then
		Drop Table sTempCluster
	End If

	'-------------------------------------------------
	' Close the the Selection table if it is
	' already/still open in the current MapInfo session
	'-------------------------------------------------
	If TableIsOpen("Selection") Then
		Close Table Selection
	End If

	'-------------------------------------------------
	' Unselect all records
	'-------------------------------------------------
	Run Menu command M_QUERY_UNSELECT

	'-------------------------------------------------
	' Drop the unique column
	'-------------------------------------------------
	'If ColumnExists(sTableName, "RowInd") Then
	'	Call MyPrint("Removing temporary key from " + sTableName + " ...")
	'	Alter Table sTableName (Drop RowInd)
	'End If

	'-------------------------------------------------
	' Add the table back to the top most map window
	' (if there is one), otherwise create a new map
	' window using the table
	'-------------------------------------------------
	'If NumWindows() > 0 Then
	'	Add Map Layer sTableName
	'Else
	'	Map From sTableName
	'End If
		
	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Goto CleanUp

End Sub

Sub SetSymbology(sLocalName As String)
'***************************************************************
'* Retrieve the symbology styles and clauses from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLTableNode As MIXmlNode
	Dim hXMLSymbologyNode As MIXmlNode
	Dim hXMLSymbolNodeList As MIXMLNodeList
	Dim hXMLSymbolNode As MIXmlNode

	OnError Goto GetSymbologyError

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataBuffer.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataBuffer node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataBuffer")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Get a handle on the OutTable node
					'-------------------------------------------------
					hXMLTableNode = MIXmlSelectSingleNode(hXMLNode, "OutTable")

					'-------------------------------------------------
					' Get a handle on the symbology node for the table
					'-------------------------------------------------
					hXMLSymbologyNode = MIXmlSelectSingleNode(hXMLTableNode, "Symbology")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLSymbolNodeList = MIXMLGetChildList(hXMLSymbologyNode)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' applying the style using the SQL clauses
					'-------------------------------------------------
					Dim i As Integer
					i = 0
					Do while hXMLSymbolNode
						
						'-------------------------------------------------
						' Close the temporary NewStyle table if it is
						' already/still open in the current MapInfo session
						'-------------------------------------------------
						If TableIsOpen("NewStyle") Then
							Close Table NewStyle
						End If

						i = i + 1

						'-------------------------------------------------
						' Set the SQL clause used to retrieve the
						' required rows from the SQL table
						'-------------------------------------------------
						Dim sClause As String, sSQLClause As String
						sClause = GetSingleNodeValue(hXMLSymbolNode, "Clause")
						If sClause <> "" Then
						    sSQLClause = " And " + sClause
						Else
						   sSQLClause = ""
						End If

						'-------------------------------------------------
						' Get the type of object (i.e. Point, line or Region)
						'-------------------------------------------------
						Dim sObject As String
						sObject = GetSingleNodeValue(hXMLSymbolNode, "Object")

						'-------------------------------------------------
						' Select all the rows of the desired object type
						' matching the required SQL clause
						'-------------------------------------------------
						Dim sCmd As String
						sCmd = "Select * From " + sLocalName + " Where Str$(obj) Like ""%" + sObject + """" + sSQLClause + " Into NewStyle NoSelect"
						Run Command (sCmd)

						'-------------------------------------------------
						' Count the number of rows selected
						'-------------------------------------------------
						Dim iRows As Integer
						iRows = TableInfo(NewStyle, TAB_INFO_NROWS)

						If sClause <> "" Then
							Call MyPrint("Setting " + sObject + " style for " + FormatNumber$(iRows) + " rows where " + sClause + " ...")
						Else
							Call MyPrint("Setting " + sObject + " style for " + FormatNumber$(iRows) + " rows ...")
						End If

						'-------------------------------------------------
						' If any rows were selected then set the styles
						'-------------------------------------------------
						If iRows > 0 Then

							'-------------------------------------------------
							' Set the styles (depending on type of object)
							'-------------------------------------------------
							Dim sSymbol, sPen, sBrush As String
							Dim stlSymbol As Symbol
							Dim stlPen As Pen
							Dim stlBrush As Brush

							Do Case sObject
								Case "Point"
									sSymbol = GetSingleNodeValue(hXMLSymbolNode, "Symbol")
									stlSymbol = STLText2Symbol(sSymbol)
								Case "Line"
									sPen = GetSingleNodeValue(hXMLSymbolNode, "Pen")
									stlPen = STLText2Pen(sPen)
								Case "Region"
									sPen = GetSingleNodeValue(hXMLSymbolNode, "Pen")
									stlPen = STLText2Pen(sPen)
									sBrush = GetSingleNodeValue(hXMLSymbolNode, "Brush")
									stlBrush = STLText2Brush(sBrush)
								Case Else
							End Case

							'-------------------------------------------------
							' Alter the object style depending on the object
							' type and style type
							'-------------------------------------------------
							Do Case sObject
								Case "Point"
									Update NewStyle Set Obj = SetStylePoint(Obj, stlSymbol)
								Case "Line"
									Update NewStyle Set Obj = SetStyleLine(Obj, stlPen)
								Case "Region"
									Update NewStyle Set Obj = SetStylePolygon(Obj, stlPen, stlBrush)
								Case Else
							End Case

						End If

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					Loop

				End If

			End If

		Else

			Note "Error : " + MIGetErrorMessage()

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Close the temporary NewStyle table if it is
	' already/still open in the current MapInfo session
	'-------------------------------------------------
	If TableIsOpen("NewStyle") Then
		Close Table NewStyle
	End If

	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLSymbolNode Then Call MIXmlNodeDestroy(hXMLSymbolNode) End If
	If hXMLSymbolNodeList Then Call MIXmlNodeListDestroy(hXMLSymbolNodeList) End If
	If hXMLSymbologyNode Then Call MIXmlNodeDestroy(hXMLSymbologyNode) End If
	If hXMLTableNode Then Call MIXmlNodeDestroy(hXMLTableNode) End If

	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetSymbologyError:
	Note str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Function SetStylePoint(ByVal oObj As Object, ByVal stlSymbol As Symbol) As Object

	Alter Object oObj Info OBJ_INFO_SYMBOL, stlSymbol
	SetStylePoint = oObj

End Function

Function SetStyleLine(ByVal oObj As Object, ByVal stlPen As Pen) As Object

	Alter Object oObj Info OBJ_INFO_PEN, stlPen
	SetStyleLine = oObj

End Function

Function SetStylePolygon(ByVal oObj As Object, ByVal stlPen As Pen, ByVal stlBrush As Brush) As Object

	Alter Object oObj Info OBJ_INFO_PEN, stlPen
	Alter Object oObj Info OBJ_INFO_BRUSH, stlBrush
	SetStylePolygon = oObj

End Function

Sub AboutBox
'***************************************************************
'* Display the 'About' dialog box
'***************************************************************

	Dialog
		Title "About Data Buffer " + sVersion
		Width 230
		Height 105

	Control StaticText
		Title "This program will buffer and, optionally, consolidate"
		Position 10,10
	Control StaticText
		Title "records from one to more MapInfo layers and merge the"
		Position 10,20
	Control StaticText
		Title "results into a single new output layer."
		Position 10,30
	Control StaticText
		Title "Created by Andy Foy Consulting."
		Position 10,50
	Control StaticText
		Title "Copyright© 2016 - 2019 TVERC, SBIC, GiGL."
		Position 10,60
	Control OKButton
		Position 185,85

End Sub

Sub MyPrint(ByVal sMsg As String)
'***************************************************************
'* Bespoke print function
'***************************************************************

	'-------------------------------------------------
	' Open the log file for output
	'-------------------------------------------------
	Open File sLogFileName For Append As #1

	'-------------------------------------------------
	' Write the message passed to the output file
	'-------------------------------------------------
	Print #1, FormatDate$(CurDate()) + " " + FormatTime$(CurTime(),"H:mm:ss") + " : " + sMsg

	'-------------------------------------------------
	' Close the output file
	'-------------------------------------------------
	Close File #1

End Sub

Sub PrintLogFile()
'***************************************************************
'* Open the log file in Notepad
'***************************************************************

	'-------------------------------------------------
	' Open the log file in Notepad
	'-------------------------------------------------
	Dim sCmd As String
	sCmd = "Run Program " +  + Chr$(34) + "NotePad.exe " + sLogFileName + Chr$(34)
	Run Command (sCmd)

End Sub

Sub egsit
'***************************************************************
'* Exit the program
'***************************************************************

	End Program

End Sub
